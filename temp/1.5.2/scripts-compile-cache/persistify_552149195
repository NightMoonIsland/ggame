{"persistifyArgs":{"cache":{"/Users/splspeco/Documents/ggame/library/imports/26/269e126c-e5ab-48f7-9161-f9928ea7591b.js":{"source":"\"use strict\";\ncc._RF.push(module, '269e1Js5atI95Fh+ZKOp1kb', 'langZh');\n// script/config/langZh.js\n\n\"use strict\";\n\nvar Lang = [];\n\nLang[\"ITEM_VALUE\"] = \"变成中文的情况\";\n\nmodule.exports = Lang;\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/1d/1de312e6-a5a6-490e-b84d-9baf27f94748.js":{"source":"\"use strict\";\ncc._RF.push(module, '1de31LmpaZJDrhNm68n+UdI', 'config');\n// script/config/config.js\n\n\"use strict\";\n\nvar Config = {};\n\nConfig.Direction = {};\nConfig.Direction.VERTICAL = 0;\nConfig.Direction.HORIZONTAL = 1;\n\nmodule.exports = Config;\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/2e/2e1f3d7e-ddfb-4a34-b096-7593b08b2c12.js":{"source":"\"use strict\";\ncc._RF.push(module, '2e1f31+3ftKNLCWdZOwiywS', 'testTs');\n// script/testTs.ts\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;\nvar NewClass = (function (_super) {\n    __extends(NewClass, _super);\n    function NewClass() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.text = 'hello';\n        return _this;\n    }\n    NewClass.prototype.onLoad = function () {\n        // init logic\n    };\n    return NewClass;\n}(cc.Component));\n__decorate([\n    property(cc.Label)\n], NewClass.prototype, \"label\", void 0);\n__decorate([\n    property({\n        default: 'hello'\n    })\n], NewClass.prototype, \"text\", void 0);\nNewClass = __decorate([\n    ccclass\n], NewClass);\nexports.default = NewClass;\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/17/1746aaa6-34f4-400c-b772-91c17f67730b.js":{"source":"\"use strict\";\ncc._RF.push(module, '1746aqmNPRADLdykcF/Z3ML', 'Renderer');\n// resources/control/Renderer.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {},\n\n    setPosY: function setPosY(y) {\n        this.node.y = y;\n    },\n\n    setPos: function setPos(x, y) {\n        this.node.x = x;\n        this.node.y = y;\n    }\n\n    // called every frame, uncomment this function to activate update callback\n    // update: function (dt) {\n\n    // },\n});\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/1e/1ec2958d-7e4a-48fb-bf0a-ddd9ad53a7f2.js":{"source":"\"use strict\";\ncc._RF.push(module, '1ec29WNfkpI+78K3dmtU6fy', 'ListView');\n// resources/control/ListView.js\n\n\"use strict\";\n\nvar _cc$Class;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar array1 = require(\"array1\");\n\ncc.Class((_cc$Class = {\n    extends: cc.Component,\n\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n\n        scrollView: {\n            default: null,\n            type: cc.ScrollView\n        },\n\n        dir: 0,\n        lines: 0,\n        hgap: 0,\n        vgap: 0,\n        width: 0,\n        height: 0,\n\n        dp: array1,\n        item: cc.Prefab,\n        itemPwd: null,\n        itemHeight: 0,\n        itemWidth: 0\n    },\n\n    ctor: function ctor() {\n        this.updateTimer = 0;\n        dp = null;\n    },\n\n    create: function create(dir, lines, hgap, vgap, width, height) {\n        this.dir = dir;\n        this.lines = lines;\n        this.hgap = hgap;\n        this.vgap = vgap;\n        this.width = width;\n        this.height = height;\n\n        this.node.parent.parent.width = width;\n        this.node.parent.parent.height = height;\n        this.node.parent.width = width;\n        this.node.parent.height = height;\n\n        // this.node.parent.parent.setContentSize(cc.Size(width, height));\n        // this.node.parent.setContentSize(cc.Size(width, height));\n        if (dir == cc.tool.config.Direction.HORIZONTAL) {\n            this.calcSection = function (self) {\n                if (!self.dp || self.dp.size() == 0) {}\n                var interval = self.itemHeight + self.vgap;\n            };\n        } else {\n            this.calcSection = function (self) {\n                if (!self.dp || self.dp.size() == 0) {}\n                var interval = self.itemHeight + self.vgap;\n            };\n        }\n    }\n\n}, _defineProperty(_cc$Class, \"ctor\", function ctor() {\n    console.log(this.width + \" wocao \" + this.height);\n}), _defineProperty(_cc$Class, \"onLoad\", function onLoad() {}), _defineProperty(_cc$Class, \"setItemModel\", function setItemModel(item, itemWidth, itemHeight) {\n    var self = this;\n\n    this.itemPwd = item;\n    // cc.loader.loadRes(item, cc.Prefab, function(err, prefab){\n    //     // cc.tool.prefab.listView = prefab;\n    //     console.log(\"type prefab = \" + typeof prefab)\n    //     self.item = prefab;\n    // });\n    cc.loader.loadRes(item, cc.Prefab);\n    self.itemWidth = itemWidth;\n    self.itemHeight = itemHeight;\n}), _defineProperty(_cc$Class, \"setDataProvider\", function setDataProvider(dl) {\n    var self = this;\n\n    if (this.dir == cc.tool.config.Direction.HORIZONTAL) {\n        this.node.height = dl.getSize() * (this.itemHeight + this.hgap) - this.hgap;\n        this.node.width = this.width;\n    } else {\n        this.node.height = this.height;\n    }\n\n    dl.excuteWithFunc(function (data, index) {\n        var prefab = cc.loader.getRes(self.itemPwd, cc.Prefab);\n\n        var item = cc.instantiate(prefab).getComponent('Renderer');\n        // item.setPosY(-this.itemHeight * (index + 1));\n        item.setPos(0, -self.itemHeight * (index + 1));\n        self.node.addChild(item.node);\n\n        // cc.loader.getRes(self.itemPwd, cc.Prefab, function(err, prefab){\n        //     let item = cc.instantiate(prefab).getComponent('Renderer');\n        //     // item.setPosY(-this.itemHeight * (index + 1));\n        //     item.setPos(0, -self.itemHeight * (index + 1));\n        //     self.node.addChild(item.node);\n        // });\n\n        // let item = cc.instantiate(self.item).getComponent('Renderer');\n        // // item.setPosY(-this.itemHeight * (index + 1));\n        // item.setPos(0, -self.itemHeight * (index + 1));\n        // self.node.addChild(item.node);\n    });\n}), _defineProperty(_cc$Class, \"update\", function update(dt) {\n    this.updateTimer += dt;\n    if (this.updateTimer < this.updateInterval) return;\n}), _cc$Class));\n\ncc._RF.pop();","deps":{"array1":"/Users/splspeco/Documents/ggame/library/imports/fb/fb6a625a-f5d3-4e3f-96e7-973a2f7a1304.js"}},"/Users/splspeco/Documents/ggame/library/imports/8f/8f625656-d45f-4ed9-934b-5999ae140e41.js":{"source":"\"use strict\";\ncc._RF.push(module, '8f625ZW1F9O2ZNLWZmuFA5B', 'viewRegister');\n// script/tool/viewRegister.js\n\n\"use strict\";\n\nconsole.log(\"heheahhaha 测试全局用法\");\n\nmodule.exports = null;\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/cc/ccacc66a-5bd8-4f79-90c7-b298d3bbe0cb.js":{"source":"\"use strict\";\ncc._RF.push(module, 'ccaccZqW9hPeZDHspjTu+DL', 'gameVariable');\n// script/variable/gameVariable.js\n\n\"use strict\";\n\nvar gameVar = [];\n\ngameVar.sec = 0;\n\nmodule.exports = gameVar;\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/c2/c2b58435-fd5e-48a7-8736-577bae06247a.js":{"source":"\"use strict\";\ncc._RF.push(module, 'c2b58Q1/V5Ip4c2V3uuBiR6', 'viewManager');\n// script/tool/viewManager.js\n\n\"use strict\";\n\ncc.Class({\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n        viewList: null,\n        viewInfo: [],\n        view: null,\n        viewName: null\n    },\n\n    ctor: function ctor() {\n        console.log(\"hhhehehe\");\n        var array1 = require(\"array1\");\n        this.viewList = new array1();\n        // this.array1 = new require(\"array1\");\n        this.viewList.status();\n        this.viewList.pushBack({ a: 1, b: 2 });\n        this.viewList.status();\n    },\n\n    setRoot: function setRoot(node) {\n        this.root = node;\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {\n        // console.log(\"hahahahha\");\n\n        // cc.variable.viewInfo.asfdfsdf();\n        // console.log(typeof this.viewName);\n    },\n\n    // called every frame, uncomment this function to activate update callback\n    // update: function (dt) {\n\n    // },\n\n    init: function init() {\n        this.viewInfo = [];\n        console.log(\"to this 1\");\n        this.viewInfo[\"haha\"] = { a: 1, b: 2 };\n        console.log(\"to this 2\");\n    },\n\n    registView: function registView(viewName, module, title) {\n        this.viewInfo[viewName] = { viewName: viewName, module: module, title: title };\n    },\n\n    changeView: function changeView(viewName) {\n        if (!this.viewList.empty() && this.viewList.back() == viewName) {\n            console.log(\"view is same\");\n            return this.view;\n        }\n\n        var viewAbout = this.viewInfo[viewName];\n        console.log(\"wocao 1\");\n        console.log(\"wocao 2\");\n\n        var idx = this.viewList.find(viewName);\n        if (idx != this.viewList.npos) {\n            var len = this.viewList.getSize() - idx;\n            this.viewList.remove(idx, len);\n        } else {\n            this.viewList.pushBack(viewName);\n        }\n        console.log(\"wocao 3\");\n\n        var self = this;\n        //通过链接 加载的资源 必须放在resource下\n        cc.loader.loadRes(viewAbout.module, function (err, prefab) {\n            var root = cc.instantiate(prefab);\n            cc.director.getScene().getChildByName(\"Canvas\").addChild(root);\n            if (self.view != null) {\n                self.view.removeFromParent();\n                self.view = null;\n            }\n            self.view = root;\n        });\n\n        this.viewName = viewName;\n        return this.view;\n    },\n\n    curView: function curView() {\n        // this.testAddChild();\n        var self = this;\n        cc.tool.eventManager.addEventListener(\"hahaha\", self, self.testAddChild);\n        cc.tool.eventManager.testWorkListener();\n        this.view.removeFromParent(false);\n        cc.loader.releaseRes(\"prefab/Test1Panel\");\n\n        return this.view;\n    },\n\n    testAddChild: function testAddChild(varName) {\n        if (varName == \"hahaha\") {\n            console.log(\"wocao tamabi\");\n        } else if (varName = \"wocaonima\") {\n            console.log(\"??? wodetian\");\n        }\n    },\n\n    curViewName: function curViewName() {\n        return this.viewName;\n    },\n\n    backPreview: function backPreview() {\n        if (this.viewList.getSize() > 0) {\n            this.viewList.popBack();\n\n            var viewName = this.viewList.back();\n            var viewAbout = this.viewInfo[viewName];\n            if (viewAbout == null) {\n                if (this.view != null) {\n                    this.view.removeFromParent();\n                }\n                this.viewName = null;\n                this.view = null;\n                return null;\n            }\n\n            var self = this;\n            cc.loader.loadRes(viewAbout.module, function (err, prefab) {\n                var root = cc.instantiate(prefab);\n                cc.director.getScene().getChildByName(\"Canvas\").addChild(root);\n                if (self.view != null) {\n                    self.view.removeFromParent();\n                    self.view = null;\n                }\n                self.view = root;\n            });\n            this.viewName = viewName;\n            return this.view;\n        }\n        return null;\n    }\n});\n\ncc._RF.pop();","deps":{"array1":"/Users/splspeco/Documents/ggame/library/imports/fb/fb6a625a-f5d3-4e3f-96e7-973a2f7a1304.js"}},"/Users/splspeco/Documents/ggame/library/imports/03/03b75b8c-1d50-4a25-a557-9d9ee429cb9e.js":{"source":"\"use strict\";\ncc._RF.push(module, '03b75uMHVBKJaVXnZ7kKcue', 'appStart');\n// script/appStart.js\n\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction init() {\n    cc.tool = {};\n    var viewManager = require(\"viewManager\");\n    cc.tool.viewManager = new viewManager();\n    cc.tool.viewManager.init();\n\n    require(\"viewRegister\");\n    viewRegister();\n\n    var timeHandler = require(\"timeHandler\");\n    cc.tool.timeHandler = new timeHandler();\n\n    var eventManager = require(\"eventManager\");\n    cc.tool.eventManager = new eventManager();\n\n    cc.tool.gameVariable = require(\"gameVariable\");\n    cc.tool.Lang = require(\"langZh\");\n\n    cc.tool.prefab = {};\n    // cc.tool.viewManager.registView(\"hahaha\", \"hehehe\", \"hihihi\");\n\n    cc.tool.config = require(\"config\");\n}\n\nfunction viewRegister() {\n    cc.tool.viewManager.registView(\"kmView\", \"ui/kmView\", 2);\n    cc.tool.viewManager.registView(\"kilie5View\", \"ui/kilie5View\", 2);\n}\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n        haha: [],\n        count: 0\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {\n        init();\n\n        // var self = this;\n        // cc.loader.loadRes(\"control/ListView\", cc.Prefab, function(err, prefab){\n        //     // cc.tool.prefab.listView = prefab;\n        //     console.log(\"type prefab = \" + typeof prefab)\n\n        //     var root = cc.instantiate(prefab);\n        //     root.setPosition(cc.v2(0, 0));\n        //     let listView = root.getChildByName(\"view\").getChildByName(\"content\").getComponent(\"ListView\");\n        //     listView.create(cc.tool.config.Direction.HORIZONTAL, 1, 1, 1, 240, 150);\n        //     listView.setItemModel(\"control/Renderer\", 160, 60);\n\n        //     var array = require(\"array1\");\n        //     var test = new array();\n        //     for(i = 0; i < 5; i++){\n        //         test.pushBack(i + 100)\n        //     }\n\n        //     listView.setDataProvider(test);\n\n\n        //     self.node.addChild(root);\n        // });\n\n        this.schedule(function () {\n            this.updateTime();\n        }, 1);\n    },\n\n    updateTime: function updateTime() {\n        console.log(\"this.count = \" + this.count);\n        this.count = this.count + 1;\n        cc.tool.eventManager.VAR_CHANGE(\"sec1\");\n        cc.tool.gameVariable.sec = cc.tool.gameVariable.sec + 1;\n    },\n\n    initScene: function initScene() {\n        // cc.tool.viewManager.setRoot(this.node);\n        // cc.tool.viewManager.changeView(\"hahhahahaa\");\n        console.log(\"test type\" + _typeof(this.haha[\"wocao\"]));\n    },\n\n    testRemove: function testRemove() {\n        cc.tool.viewManager.changeView(\"kmView\");\n    },\n\n    btnBack: function btnBack() {\n        cc.tool.viewManager.backPreview();\n    }\n\n});\n\ncc._RF.pop();","deps":{"viewManager":"/Users/splspeco/Documents/ggame/library/imports/c2/c2b58435-fd5e-48a7-8736-577bae06247a.js","viewRegister":"/Users/splspeco/Documents/ggame/library/imports/8f/8f625656-d45f-4ed9-934b-5999ae140e41.js","timeHandler":"/Users/splspeco/Documents/ggame/library/imports/97/977cc0e1-2e1d-414e-8141-f64843a5d362.js","eventManager":"/Users/splspeco/Documents/ggame/library/imports/d1/d1f6d160-3543-49da-a12f-e0853acf5abe.js","gameVariable":"/Users/splspeco/Documents/ggame/library/imports/cc/ccacc66a-5bd8-4f79-90c7-b298d3bbe0cb.js","langZh":"/Users/splspeco/Documents/ggame/library/imports/26/269e126c-e5ab-48f7-9161-f9928ea7591b.js","config":"/Users/splspeco/Documents/ggame/library/imports/1d/1de312e6-a5a6-490e-b84d-9baf27f94748.js"}},"/Users/splspeco/Documents/ggame/library/imports/e3/e3999068-9648-49a5-84b6-27fc6eb337db.js":{"source":"\"use strict\";\ncc._RF.push(module, 'e3999BolkhJpYS2J/xuszfb', 'kmView');\n// script/module/kmView.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n        eventType: null\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {\n        this.eventType = new Array(\"sec1\", \"sec2\", \"sec3\");\n\n        var self = this;\n        for (var i = 0; i < this.eventType.length; i++) {\n            cc.tool.eventManager.addEventListener(self.eventType[i], self, self.onVarCallback);\n        }\n    },\n\n    onVarCallback: function onVarCallback(self, varName) {\n        if (varName == \"sec1\") {\n            //self.output();\n            self.node.getChildByName(\"txthaha\").getComponent(cc.Label).string = \"sec = \" + cc.tool.gameVariable.sec;\n        } else if (varName == \"\") {}\n    },\n\n    output: function output() {\n        console.log(\"wo cao ni ma ge chou hai\");\n    },\n\n    // called every frame, uncomment this function to activate update callback\n    // update: function (dt) {\n\n    // },\n\n    btnTeam: function btnTeam() {\n\n        // cc.tool.viewManager.changeView(\"kilie5View\");\n    }\n});\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/e3/e33a4d6e-3979-4e7c-9b13-a4f530f47026.js":{"source":"\"use strict\";\ncc._RF.push(module, 'e33a41uOXlOfJsTpPUw9HAm', 'test');\n// script/tool/test.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {},\n\n    testWork: function testWork() {\n        console.log(\"wocao nimabi\");\n    }\n\n});\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/d1/d1f6d160-3543-49da-a12f-e0853acf5abe.js":{"source":"\"use strict\";\ncc._RF.push(module, 'd1f6dFgNUNJ2qEv4IU6z1q+', 'eventManager');\n// script/tool/eventManager.js\n\n\"use strict\";\n\nvar array1 = require(\"array1\");\nvar test = require(\"test\");\n\ncc.Class({\n    extends: test,\n\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n        eventListener: []\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {},\n\n    init: function init() {\n        this.super.testWork();\n    },\n\n    testWork: function testWork() {\n        console.log(\"zenme hui zheyang\");\n    },\n\n    addEventListener: function addEventListener(eventType, target, func) {\n        target.output();\n        // console.log()\n        if (!target || !func) return;\n        if (!this.eventListener[eventType]) {\n            this.eventListener[eventType] = new array1();\n        }\n        this.eventListener[eventType].pushBack({ target: target, func: func });\n    },\n\n    testWorkListener: function testWorkListener() {\n        console.log(\"to test listener\");\n        for (var key in this.eventListener[\"hahaha\"]) {\n            var func = this.eventListener[\"hahaha\"][key];\n            func(\"hahaha\");\n        }\n    },\n\n    dispatchEventListener: function dispatchEventListener(eventType) {\n        this.eventListener[eventType].excuteWithFunc(function (item, index) {\n            var func = item.func;\n            var target = item.target;\n            func(target, eventType);\n        });\n        // for(var key in this.eventListener[eventType]){\n        //     var func = this.eventListener[eventType][key];\n        //     func(key, eventType);\n        // }\n    },\n\n    VAR_CHANGE: function VAR_CHANGE(varName) {\n        this.dispatchEventListener(varName);\n    }\n\n});\n\ncc._RF.pop();","deps":{"array1":"/Users/splspeco/Documents/ggame/library/imports/fb/fb6a625a-f5d3-4e3f-96e7-973a2f7a1304.js","test":"/Users/splspeco/Documents/ggame/library/imports/e3/e33a4d6e-3979-4e7c-9b13-a4f530f47026.js"}},"/Users/splspeco/Documents/ggame/library/imports/a5/a508d847-3b2e-4916-9df9-7d0fd56f61b0.js":{"source":"\"use strict\";\ncc._RF.push(module, 'a508dhHOy5JFp35fQ/Vb2Gw', 'urlManager');\n// script/tool/urlManager.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {}\n\n});\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/97/977cc0e1-2e1d-414e-8141-f64843a5d362.js":{"source":"\"use strict\";\ncc._RF.push(module, '977ccDhLh1BToFB9khDpdNi', 'timeHandler');\n// script/process/timeHandler.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n        count: 0\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {},\n\n    ctor: function ctor() {\n        console.log(\"zenm ehuizheyang\");\n        this.schedule(function () {\n            console.log(\"hahahahahha\");\n        }, 1);\n    },\n\n    dosomething: function dosomething() {\n        console.log(\"dsgfsdagvdga\");\n        // console.log(\"this.count = \" + this.count);\n        // this.count = this.count + 1;\n    }\n});\n\ncc._RF.pop();","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/25/25f6293b-798b-438e-aea3-9aa9f8bbd43f.js":{"source":"(function (global){\n\"use strict\";\ncc._RF.push(module, '25f62k7eYtDjq6jmqn4u9Q/', 'socket.io');\n// script/tool/socket.io.js\n\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (f) {\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }g.io = f();\n  }\n})(function () {\n  var define, module, exports;return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n        }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }return n[o].exports;\n    }var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {\n      s(r[o]);\n    }return s;\n  }({ 1: [function (_dereq_, module, exports) {\n\n      /**\n       * Module dependencies.\n       */\n\n      var url = _dereq_('./url');\n      var parser = _dereq_('socket.io-parser');\n      var Manager = _dereq_('./manager');\n      var debug = _dereq_('debug')('socket.io-client');\n\n      /**\n       * Module exports.\n       */\n\n      module.exports = exports = lookup;\n\n      /**\n       * Managers cache.\n       */\n\n      var cache = exports.managers = {};\n\n      /**\n       * Looks up an existing `Manager` for multiplexing.\n       * If the user summons:\n       *\n       *   `io('http://localhost/a');`\n       *   `io('http://localhost/b');`\n       *\n       * We reuse the existing instance based on same scheme/port/host,\n       * and we initialize sockets for each namespace.\n       *\n       * @api public\n       */\n\n      function lookup(uri, opts) {\n        if ((typeof uri === \"undefined\" ? \"undefined\" : _typeof(uri)) == 'object') {\n          opts = uri;\n          uri = undefined;\n        }\n\n        opts = opts || {};\n\n        var parsed = url(uri);\n        var source = parsed.source;\n        var id = parsed.id;\n        var path = parsed.path;\n        var sameNamespace = cache[id] && path in cache[id].nsps;\n        var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;\n\n        var io;\n\n        if (newConnection) {\n          debug('ignoring socket cache for %s', source);\n          io = Manager(source, opts);\n        } else {\n          if (!cache[id]) {\n            debug('new io instance for %s', source);\n            cache[id] = Manager(source, opts);\n          }\n          io = cache[id];\n        }\n\n        return io.socket(parsed.path);\n      }\n\n      /**\n       * Protocol version.\n       *\n       * @api public\n       */\n\n      exports.protocol = parser.protocol;\n\n      /**\n       * `connect`.\n       *\n       * @param {String} uri\n       * @api public\n       */\n\n      exports.connect = lookup;\n\n      /**\n       * Expose constructors for standalone build.\n       *\n       * @api public\n       */\n\n      exports.Manager = _dereq_('./manager');\n      exports.Socket = _dereq_('./socket');\n    }, { \"./manager\": 2, \"./socket\": 4, \"./url\": 5, \"debug\": 14, \"socket.io-parser\": 40 }], 2: [function (_dereq_, module, exports) {\n\n      /**\n       * Module dependencies.\n       */\n\n      var eio = _dereq_('engine.io-client');\n      var Socket = _dereq_('./socket');\n      var Emitter = _dereq_('component-emitter');\n      var parser = _dereq_('socket.io-parser');\n      var on = _dereq_('./on');\n      var bind = _dereq_('component-bind');\n      var debug = _dereq_('debug')('socket.io-client:manager');\n      var indexOf = _dereq_('indexof');\n      var Backoff = _dereq_('backo2');\n\n      /**\n       * IE6+ hasOwnProperty\n       */\n\n      var has = Object.prototype.hasOwnProperty;\n\n      /**\n       * Module exports\n       */\n\n      module.exports = Manager;\n\n      /**\n       * `Manager` constructor.\n       *\n       * @param {String} engine instance or engine uri/opts\n       * @param {Object} options\n       * @api public\n       */\n\n      function Manager(uri, opts) {\n        if (!(this instanceof Manager)) return new Manager(uri, opts);\n        if (uri && 'object' == (typeof uri === \"undefined\" ? \"undefined\" : _typeof(uri))) {\n          opts = uri;\n          uri = undefined;\n        }\n        opts = opts || {};\n\n        opts.path = opts.path || '/socket.io';\n        this.nsps = {};\n        this.subs = [];\n        this.opts = opts;\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor(opts.randomizationFactor || 0.5);\n        this.backoff = new Backoff({\n          min: this.reconnectionDelay(),\n          max: this.reconnectionDelayMax(),\n          jitter: this.randomizationFactor()\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this.readyState = 'closed';\n        this.uri = uri;\n        this.connecting = [];\n        this.lastPing = null;\n        this.encoding = false;\n        this.packetBuffer = [];\n        this.encoder = new parser.Encoder();\n        this.decoder = new parser.Decoder();\n        this.autoConnect = opts.autoConnect !== false;\n        if (this.autoConnect) this.open();\n      }\n\n      /**\n       * Propagate given event to sockets and emit on `this`\n       *\n       * @api private\n       */\n\n      Manager.prototype.emitAll = function () {\n        this.emit.apply(this, arguments);\n        for (var nsp in this.nsps) {\n          if (has.call(this.nsps, nsp)) {\n            this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n          }\n        }\n      };\n\n      /**\n       * Update `socket.id` of all sockets\n       *\n       * @api private\n       */\n\n      Manager.prototype.updateSocketIds = function () {\n        for (var nsp in this.nsps) {\n          if (has.call(this.nsps, nsp)) {\n            this.nsps[nsp].id = this.engine.id;\n          }\n        }\n      };\n\n      /**\n       * Mix in `Emitter`.\n       */\n\n      Emitter(Manager.prototype);\n\n      /**\n       * Sets the `reconnection` config.\n       *\n       * @param {Boolean} true/false if it should automatically reconnect\n       * @return {Manager} self or value\n       * @api public\n       */\n\n      Manager.prototype.reconnection = function (v) {\n        if (!arguments.length) return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n      };\n\n      /**\n       * Sets the reconnection attempts config.\n       *\n       * @param {Number} max reconnection attempts before giving up\n       * @return {Manager} self or value\n       * @api public\n       */\n\n      Manager.prototype.reconnectionAttempts = function (v) {\n        if (!arguments.length) return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n      };\n\n      /**\n       * Sets the delay between reconnections.\n       *\n       * @param {Number} delay\n       * @return {Manager} self or value\n       * @api public\n       */\n\n      Manager.prototype.reconnectionDelay = function (v) {\n        if (!arguments.length) return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        this.backoff && this.backoff.setMin(v);\n        return this;\n      };\n\n      Manager.prototype.randomizationFactor = function (v) {\n        if (!arguments.length) return this._randomizationFactor;\n        this._randomizationFactor = v;\n        this.backoff && this.backoff.setJitter(v);\n        return this;\n      };\n\n      /**\n       * Sets the maximum delay between reconnections.\n       *\n       * @param {Number} delay\n       * @return {Manager} self or value\n       * @api public\n       */\n\n      Manager.prototype.reconnectionDelayMax = function (v) {\n        if (!arguments.length) return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        this.backoff && this.backoff.setMax(v);\n        return this;\n      };\n\n      /**\n       * Sets the connection timeout. `false` to disable\n       *\n       * @return {Manager} self or value\n       * @api public\n       */\n\n      Manager.prototype.timeout = function (v) {\n        if (!arguments.length) return this._timeout;\n        this._timeout = v;\n        return this;\n      };\n\n      /**\n       * Starts trying to reconnect if reconnection is enabled and we have not\n       * started reconnecting yet\n       *\n       * @api private\n       */\n\n      Manager.prototype.maybeReconnectOnOpen = function () {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n          // keeps reconnection from firing twice for the same reconnection loop\n          this.reconnect();\n        }\n      };\n\n      /**\n       * Sets the current transport `socket`.\n       *\n       * @param {Function} optional, callback\n       * @return {Manager} self\n       * @api public\n       */\n\n      Manager.prototype.open = Manager.prototype.connect = function (fn) {\n        debug('readyState %s', this.readyState);\n        if (\\x7ethis.readyState.indexOf('open')) return this;\n\n        debug('opening %s', this.uri);\n        this.engine = eio(this.uri, this.opts);\n        var socket = this.engine;\n        var self = this;\n        this.readyState = 'opening';\n        this.skipReconnect = false;\n\n        // emit `open`\n        var openSub = on(socket, 'open', function () {\n          self.onopen();\n          fn && fn();\n        });\n\n        // emit `connect_error`\n        var errorSub = on(socket, 'error', function (data) {\n          debug('connect_error');\n          self.cleanup();\n          self.readyState = 'closed';\n          self.emitAll('connect_error', data);\n          if (fn) {\n            var err = new Error('Connection error');\n            err.data = data;\n            fn(err);\n          } else {\n            // Only do this if there is no fn to handle the error\n            self.maybeReconnectOnOpen();\n          }\n        });\n\n        // emit `connect_timeout`\n        if (false !== this._timeout) {\n          var timeout = this._timeout;\n          debug('connect attempt will timeout after %d', timeout);\n\n          // set timer\n          var timer = setTimeout(function () {\n            debug('connect attempt timed out after %d', timeout);\n            openSub.destroy();\n            socket.close();\n            socket.emit('error', 'timeout');\n            self.emitAll('connect_timeout', timeout);\n          }, timeout);\n\n          this.subs.push({\n            destroy: function destroy() {\n              clearTimeout(timer);\n            }\n          });\n        }\n\n        this.subs.push(openSub);\n        this.subs.push(errorSub);\n\n        return this;\n      };\n\n      /**\n       * Called upon transport open.\n       *\n       * @api private\n       */\n\n      Manager.prototype.onopen = function () {\n        debug('open');\n\n        // clear old subs\n        this.cleanup();\n\n        // mark as open\n        this.readyState = 'open';\n        this.emit('open');\n\n        // add new subs\n        var socket = this.engine;\n        this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n        this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n        this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n        this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n        this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n        this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n      };\n\n      /**\n       * Called upon a ping.\n       *\n       * @api private\n       */\n\n      Manager.prototype.onping = function () {\n        this.lastPing = new Date();\n        this.emitAll('ping');\n      };\n\n      /**\n       * Called upon a packet.\n       *\n       * @api private\n       */\n\n      Manager.prototype.onpong = function () {\n        this.emitAll('pong', new Date() - this.lastPing);\n      };\n\n      /**\n       * Called with data.\n       *\n       * @api private\n       */\n\n      Manager.prototype.ondata = function (data) {\n        this.decoder.add(data);\n      };\n\n      /**\n       * Called when parser fully decodes a packet.\n       *\n       * @api private\n       */\n\n      Manager.prototype.ondecoded = function (packet) {\n        this.emit('packet', packet);\n      };\n\n      /**\n       * Called upon socket error.\n       *\n       * @api private\n       */\n\n      Manager.prototype.onerror = function (err) {\n        debug('error', err);\n        this.emitAll('error', err);\n      };\n\n      /**\n       * Creates a new socket for the given `nsp`.\n       *\n       * @return {Socket}\n       * @api public\n       */\n\n      Manager.prototype.socket = function (nsp) {\n        var socket = this.nsps[nsp];\n        if (!socket) {\n          socket = new Socket(this, nsp);\n          this.nsps[nsp] = socket;\n          var self = this;\n          socket.on('connecting', onConnecting);\n          socket.on('connect', function () {\n            socket.id = self.engine.id;\n          });\n\n          if (this.autoConnect) {\n            // manually call here since connecting evnet is fired before listening\n            onConnecting();\n          }\n        }\n\n        function onConnecting() {\n          if (!~indexOf(self.connecting, socket)) {\n            self.connecting.push(socket);\n          }\n        }\n\n        return socket;\n      };\n\n      /**\n       * Called upon a socket close.\n       *\n       * @param {Socket} socket\n       */\n\n      Manager.prototype.destroy = function (socket) {\n        var index = indexOf(this.connecting, socket);\n        if (~index) this.connecting.splice(index, 1);\n        if (this.connecting.length) return;\n\n        this.close();\n      };\n\n      /**\n       * Writes a packet.\n       *\n       * @param {Object} packet\n       * @api private\n       */\n\n      Manager.prototype.packet = function (packet) {\n        debug('writing packet %j', packet);\n        var self = this;\n\n        if (!self.encoding) {\n          // encode, then write to engine with result\n          self.encoding = true;\n          this.encoder.encode(packet, function (encodedPackets) {\n            for (var i = 0; i < encodedPackets.length; i++) {\n              self.engine.write(encodedPackets[i], packet.options);\n            }\n            self.encoding = false;\n            self.processPacketQueue();\n          });\n        } else {\n          // add packet to the queue\n          self.packetBuffer.push(packet);\n        }\n      };\n\n      /**\n       * If packet buffer is non-empty, begins encoding the\n       * next packet in line.\n       *\n       * @api private\n       */\n\n      Manager.prototype.processPacketQueue = function () {\n        if (this.packetBuffer.length > 0 && !this.encoding) {\n          var pack = this.packetBuffer.shift();\n          this.packet(pack);\n        }\n      };\n\n      /**\n       * Clean up transport subscriptions and packet buffer.\n       *\n       * @api private\n       */\n\n      Manager.prototype.cleanup = function () {\n        debug('cleanup');\n\n        var sub;\n        while (sub = this.subs.shift()) {\n          sub.destroy();\n        }this.packetBuffer = [];\n        this.encoding = false;\n        this.lastPing = null;\n\n        this.decoder.destroy();\n      };\n\n      /**\n       * Close the current socket.\n       *\n       * @api private\n       */\n\n      Manager.prototype.close = Manager.prototype.disconnect = function () {\n        debug('disconnect');\n        this.skipReconnect = true;\n        this.reconnecting = false;\n        if ('opening' == this.readyState) {\n          // `onclose` will not fire because\n          // an open event never happened\n          this.cleanup();\n        }\n        this.backoff.reset();\n        this.readyState = 'closed';\n        if (this.engine) this.engine.close();\n      };\n\n      /**\n       * Called upon engine close.\n       *\n       * @api private\n       */\n\n      Manager.prototype.onclose = function (reason) {\n        debug('onclose');\n\n        this.cleanup();\n        this.backoff.reset();\n        this.readyState = 'closed';\n        this.emit('close', reason);\n\n        if (this._reconnection && !this.skipReconnect) {\n          this.reconnect();\n        }\n      };\n\n      /**\n       * Attempt a reconnection.\n       *\n       * @api private\n       */\n\n      Manager.prototype.reconnect = function () {\n        if (this.reconnecting || this.skipReconnect) return this;\n\n        var self = this;\n\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n          debug('reconnect failed');\n          this.backoff.reset();\n          this.emitAll('reconnect_failed');\n          this.reconnecting = false;\n        } else {\n          var delay = this.backoff.duration();\n          debug('will wait %dms before reconnect attempt', delay);\n\n          this.reconnecting = true;\n          var timer = setTimeout(function () {\n            if (self.skipReconnect) return;\n\n            debug('attempting reconnect');\n            self.emitAll('reconnect_attempt', self.backoff.attempts);\n            self.emitAll('reconnecting', self.backoff.attempts);\n\n            // check again for the case socket closed in above events\n            if (self.skipReconnect) return;\n\n            self.open(function (err) {\n              if (err) {\n                debug('reconnect attempt error');\n                self.reconnecting = false;\n                self.reconnect();\n                self.emitAll('reconnect_error', err.data);\n              } else {\n                debug('reconnect success');\n                self.onreconnect();\n              }\n            });\n          }, delay);\n\n          this.subs.push({\n            destroy: function destroy() {\n              clearTimeout(timer);\n            }\n          });\n        }\n      };\n\n      /**\n       * Called upon successful reconnect.\n       *\n       * @api private\n       */\n\n      Manager.prototype.onreconnect = function () {\n        var attempt = this.backoff.attempts;\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.updateSocketIds();\n        this.emitAll('reconnect', attempt);\n      };\n    }, { \"./on\": 3, \"./socket\": 4, \"backo2\": 8, \"component-bind\": 11, \"component-emitter\": 12, \"debug\": 14, \"engine.io-client\": 16, \"indexof\": 32, \"socket.io-parser\": 40 }], 3: [function (_dereq_, module, exports) {\n\n      /**\n       * Module exports.\n       */\n\n      module.exports = on;\n\n      /**\n       * Helper for subscriptions.\n       *\n       * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n       * @param {String} event name\n       * @param {Function} callback\n       * @api public\n       */\n\n      function on(obj, ev, fn) {\n        obj.on(ev, fn);\n        return {\n          destroy: function destroy() {\n            obj.removeListener(ev, fn);\n          }\n        };\n      }\n    }, {}], 4: [function (_dereq_, module, exports) {\n\n      /**\n       * Module dependencies.\n       */\n\n      var parser = _dereq_('socket.io-parser');\n      var Emitter = _dereq_('component-emitter');\n      var toArray = _dereq_('to-array');\n      var on = _dereq_('./on');\n      var bind = _dereq_('component-bind');\n      var debug = _dereq_('debug')('socket.io-client:socket');\n      var hasBin = _dereq_('has-binary');\n\n      /**\n       * Module exports.\n       */\n\n      module.exports = exports = Socket;\n\n      /**\n       * Internal events (blacklisted).\n       * These events can't be emitted by the user.\n       *\n       * @api private\n       */\n\n      var events = {\n        connect: 1,\n        connect_error: 1,\n        connect_timeout: 1,\n        connecting: 1,\n        disconnect: 1,\n        error: 1,\n        reconnect: 1,\n        reconnect_attempt: 1,\n        reconnect_failed: 1,\n        reconnect_error: 1,\n        reconnecting: 1,\n        ping: 1,\n        pong: 1\n      };\n\n      /**\n       * Shortcut to `Emitter#emit`.\n       */\n\n      var emit = Emitter.prototype.emit;\n\n      /**\n       * `Socket` constructor.\n       *\n       * @api public\n       */\n\n      function Socket(io, nsp) {\n        this.io = io;\n        this.nsp = nsp;\n        this.json = this; // compat\n        this.ids = 0;\n        this.acks = {};\n        this.receiveBuffer = [];\n        this.sendBuffer = [];\n        this.connected = false;\n        this.disconnected = true;\n        if (this.io.autoConnect) this.open();\n      }\n\n      /**\n       * Mix in `Emitter`.\n       */\n\n      Emitter(Socket.prototype);\n\n      /**\n       * Subscribe to open, close and packet events\n       *\n       * @api private\n       */\n\n      Socket.prototype.subEvents = function () {\n        if (this.subs) return;\n\n        var io = this.io;\n        this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];\n      };\n\n      /**\n       * \"Opens\" the socket.\n       *\n       * @api public\n       */\n\n      Socket.prototype.open = Socket.prototype.connect = function () {\n        if (this.connected) return this;\n\n        this.subEvents();\n        this.io.open(); // ensure open\n        if ('open' == this.io.readyState) this.onopen();\n        this.emit('connecting');\n        return this;\n      };\n\n      /**\n       * Sends a `message` event.\n       *\n       * @return {Socket} self\n       * @api public\n       */\n\n      Socket.prototype.send = function () {\n        var args = toArray(arguments);\n        args.unshift('message');\n        this.emit.apply(this, args);\n        return this;\n      };\n\n      /**\n       * Override `emit`.\n       * If the event is in `events`, it's emitted normally.\n       *\n       * @param {String} event name\n       * @return {Socket} self\n       * @api public\n       */\n\n      Socket.prototype.emit = function (ev) {\n        if (events.hasOwnProperty(ev)) {\n          emit.apply(this, arguments);\n          return this;\n        }\n\n        var args = toArray(arguments);\n        var parserType = parser.EVENT; // default\n        if (hasBin(args)) {\n          parserType = parser.BINARY_EVENT;\n        } // binary\n        var packet = { type: parserType, data: args };\n\n        packet.options = {};\n        packet.options.compress = !this.flags || false !== this.flags.compress;\n\n        // event ack callback\n        if ('function' == typeof args[args.length - 1]) {\n          debug('emitting packet with ack id %d', this.ids);\n          this.acks[this.ids] = args.pop();\n          packet.id = this.ids++;\n        }\n\n        if (this.connected) {\n          this.packet(packet);\n        } else {\n          this.sendBuffer.push(packet);\n        }\n\n        delete this.flags;\n\n        return this;\n      };\n\n      /**\n       * Sends a packet.\n       *\n       * @param {Object} packet\n       * @api private\n       */\n\n      Socket.prototype.packet = function (packet) {\n        packet.nsp = this.nsp;\n        this.io.packet(packet);\n      };\n\n      /**\n       * Called upon engine `open`.\n       *\n       * @api private\n       */\n\n      Socket.prototype.onopen = function () {\n        debug('transport is open - connecting');\n\n        // write connect packet if necessary\n        if ('/' != this.nsp) {\n          this.packet({ type: parser.CONNECT });\n        }\n      };\n\n      /**\n       * Called upon engine `close`.\n       *\n       * @param {String} reason\n       * @api private\n       */\n\n      Socket.prototype.onclose = function (reason) {\n        debug('close (%s)', reason);\n        this.connected = false;\n        this.disconnected = true;\n        delete this.id;\n        this.emit('disconnect', reason);\n      };\n\n      /**\n       * Called with socket packet.\n       *\n       * @param {Object} packet\n       * @api private\n       */\n\n      Socket.prototype.onpacket = function (packet) {\n        if (packet.nsp != this.nsp) return;\n\n        switch (packet.type) {\n          case parser.CONNECT:\n            this.onconnect();\n            break;\n\n          case parser.EVENT:\n            this.onevent(packet);\n            break;\n\n          case parser.BINARY_EVENT:\n            this.onevent(packet);\n            break;\n\n          case parser.ACK:\n            this.onack(packet);\n            break;\n\n          case parser.BINARY_ACK:\n            this.onack(packet);\n            break;\n\n          case parser.DISCONNECT:\n            this.ondisconnect();\n            break;\n\n          case parser.ERROR:\n            this.emit('error', packet.data);\n            break;\n        }\n      };\n\n      /**\n       * Called upon a server event.\n       *\n       * @param {Object} packet\n       * @api private\n       */\n\n      Socket.prototype.onevent = function (packet) {\n        var args = packet.data || [];\n        debug('emitting event %j', args);\n\n        if (null != packet.id) {\n          debug('attaching ack callback to event');\n          args.push(this.ack(packet.id));\n        }\n\n        if (this.connected) {\n          emit.apply(this, args);\n        } else {\n          this.receiveBuffer.push(args);\n        }\n      };\n\n      /**\n       * Produces an ack callback to emit with an event.\n       *\n       * @api private\n       */\n\n      Socket.prototype.ack = function (id) {\n        var self = this;\n        var sent = false;\n        return function () {\n          // prevent double callbacks\n          if (sent) return;\n          sent = true;\n          var args = toArray(arguments);\n          debug('sending ack %j', args);\n\n          var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n          self.packet({\n            type: type,\n            id: id,\n            data: args\n          });\n        };\n      };\n\n      /**\n       * Called upon a server acknowlegement.\n       *\n       * @param {Object} packet\n       * @api private\n       */\n\n      Socket.prototype.onack = function (packet) {\n        var ack = this.acks[packet.id];\n        if ('function' == typeof ack) {\n          debug('calling ack %s with %j', packet.id, packet.data);\n          ack.apply(this, packet.data);\n          delete this.acks[packet.id];\n        } else {\n          debug('bad ack %s', packet.id);\n        }\n      };\n\n      /**\n       * Called upon server connect.\n       *\n       * @api private\n       */\n\n      Socket.prototype.onconnect = function () {\n        this.connected = true;\n        this.disconnected = false;\n        this.emit('connect');\n        this.emitBuffered();\n      };\n\n      /**\n       * Emit buffered events (received and emitted).\n       *\n       * @api private\n       */\n\n      Socket.prototype.emitBuffered = function () {\n        var i;\n        for (i = 0; i < this.receiveBuffer.length; i++) {\n          emit.apply(this, this.receiveBuffer[i]);\n        }\n        this.receiveBuffer = [];\n\n        for (i = 0; i < this.sendBuffer.length; i++) {\n          this.packet(this.sendBuffer[i]);\n        }\n        this.sendBuffer = [];\n      };\n\n      /**\n       * Called upon server disconnect.\n       *\n       * @api private\n       */\n\n      Socket.prototype.ondisconnect = function () {\n        debug('server disconnect (%s)', this.nsp);\n        this.destroy();\n        this.onclose('io server disconnect');\n      };\n\n      /**\n       * Called upon forced client/server side disconnections,\n       * this method ensures the manager stops tracking us and\n       * that reconnections don't get triggered for this.\n       *\n       * @api private.\n       */\n\n      Socket.prototype.destroy = function () {\n        if (this.subs) {\n          // clean subscriptions to avoid reconnections\n          for (var i = 0; i < this.subs.length; i++) {\n            this.subs[i].destroy();\n          }\n          this.subs = null;\n        }\n\n        this.io.destroy(this);\n      };\n\n      /**\n       * Disconnects the socket manually.\n       *\n       * @return {Socket} self\n       * @api public\n       */\n\n      Socket.prototype.close = Socket.prototype.disconnect = function () {\n        if (this.connected) {\n          debug('performing disconnect (%s)', this.nsp);\n          this.packet({ type: parser.DISCONNECT });\n        }\n\n        // remove socket from pool\n        this.destroy();\n\n        if (this.connected) {\n          // fire events\n          this.onclose('io client disconnect');\n        }\n        return this;\n      };\n\n      /**\n       * Sets the compress flag.\n       *\n       * @param {Boolean} if `true`, compresses the sending data\n       * @return {Socket} self\n       * @api public\n       */\n\n      Socket.prototype.compress = function (compress) {\n        this.flags = this.flags || {};\n        this.flags.compress = compress;\n        return this;\n      };\n    }, { \"./on\": 3, \"component-bind\": 11, \"component-emitter\": 12, \"debug\": 14, \"has-binary\": 30, \"socket.io-parser\": 40, \"to-array\": 43 }], 5: [function (_dereq_, module, exports) {\n      (function (global) {\n\n        /**\n         * Module dependencies.\n         */\n\n        var parseuri = _dereq_('parseuri');\n        var debug = _dereq_('debug')('socket.io-client:url');\n\n        /**\n         * Module exports.\n         */\n\n        module.exports = url;\n\n        /**\n         * URL parser.\n         *\n         * @param {String} url\n         * @param {Object} An object meant to mimic window.location.\n         *                 Defaults to window.location.\n         * @api public\n         */\n\n        function url(uri, loc) {\n          var obj = uri;\n\n          // default to window.location\n          var loc = loc || global.location;\n          if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n          // relative path support\n          if ('string' == typeof uri) {\n            if ('/' == uri.charAt(0)) {\n              if ('/' == uri.charAt(1)) {\n                uri = loc.protocol + uri;\n              } else {\n                uri = loc.host + uri;\n              }\n            }\n\n            if (!/^(https?|wss?):\\/\\//.test(uri)) {\n              debug('protocol-less url %s', uri);\n              if ('undefined' != typeof loc) {\n                uri = loc.protocol + '//' + uri;\n              } else {\n                uri = 'https://' + uri;\n              }\n            }\n\n            // parse\n            debug('parse %s', uri);\n            obj = parseuri(uri);\n          }\n\n          // make sure we treat `localhost:80` and `localhost` equally\n          if (!obj.port) {\n            if (/^(http|ws)$/.test(obj.protocol)) {\n              obj.port = '80';\n            } else if (/^(http|ws)s$/.test(obj.protocol)) {\n              obj.port = '443';\n            }\n          }\n\n          obj.path = obj.path || '/';\n\n          var ipv6 = obj.host.indexOf(':') !== -1;\n          var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\n          // define unique id\n          obj.id = obj.protocol + '://' + host + ':' + obj.port;\n          // define href\n          obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : ':' + obj.port);\n\n          return obj;\n        }\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"debug\": 14, \"parseuri\": 38 }], 6: [function (_dereq_, module, exports) {\n      module.exports = after;\n\n      function after(count, callback, err_cb) {\n        var bail = false;\n        err_cb = err_cb || noop;\n        proxy.count = count;\n\n        return count === 0 ? callback() : proxy;\n\n        function proxy(err, result) {\n          if (proxy.count <= 0) {\n            throw new Error('after called too many times');\n          }\n          --proxy.count;\n\n          // after first error, rest are passed to err_cb\n          if (err) {\n            bail = true;\n            callback(err);\n            // future error callbacks will go to error handler\n            callback = err_cb;\n          } else if (proxy.count === 0 && !bail) {\n            callback(null, result);\n          }\n        }\n      }\n\n      function noop() {}\n    }, {}], 7: [function (_dereq_, module, exports) {\n      /**\n       * An abstraction for slicing an arraybuffer even when\n       * ArrayBuffer.prototype.slice is not supported\n       *\n       * @api public\n       */\n\n      module.exports = function (arraybuffer, start, end) {\n        var bytes = arraybuffer.byteLength;\n        start = start || 0;\n        end = end || bytes;\n\n        if (arraybuffer.slice) {\n          return arraybuffer.slice(start, end);\n        }\n\n        if (start < 0) {\n          start += bytes;\n        }\n        if (end < 0) {\n          end += bytes;\n        }\n        if (end > bytes) {\n          end = bytes;\n        }\n\n        if (start >= bytes || start >= end || bytes === 0) {\n          return new ArrayBuffer(0);\n        }\n\n        var abv = new Uint8Array(arraybuffer);\n        var result = new Uint8Array(end - start);\n        for (var i = start, ii = 0; i < end; i++, ii++) {\n          result[ii] = abv[i];\n        }\n        return result.buffer;\n      };\n    }, {}], 8: [function (_dereq_, module, exports) {\n\n      /**\n       * Expose `Backoff`.\n       */\n\n      module.exports = Backoff;\n\n      /**\n       * Initialize backoff timer with `opts`.\n       *\n       * - `min` initial timeout in milliseconds [100]\n       * - `max` max timeout [10000]\n       * - `jitter` [0]\n       * - `factor` [2]\n       *\n       * @param {Object} opts\n       * @api public\n       */\n\n      function Backoff(opts) {\n        opts = opts || {};\n        this.ms = opts.min || 100;\n        this.max = opts.max || 10000;\n        this.factor = opts.factor || 2;\n        this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n        this.attempts = 0;\n      }\n\n      /**\n       * Return the backoff duration.\n       *\n       * @return {Number}\n       * @api public\n       */\n\n      Backoff.prototype.duration = function () {\n        var ms = this.ms * Math.pow(this.factor, this.attempts++);\n        if (this.jitter) {\n          var rand = Math.random();\n          var deviation = Math.floor(rand * this.jitter * ms);\n          ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n        }\n        return Math.min(ms, this.max) | 0;\n      };\n\n      /**\n       * Reset the number of attempts.\n       *\n       * @api public\n       */\n\n      Backoff.prototype.reset = function () {\n        this.attempts = 0;\n      };\n\n      /**\n       * Set the minimum duration\n       *\n       * @api public\n       */\n\n      Backoff.prototype.setMin = function (min) {\n        this.ms = min;\n      };\n\n      /**\n       * Set the maximum duration\n       *\n       * @api public\n       */\n\n      Backoff.prototype.setMax = function (max) {\n        this.max = max;\n      };\n\n      /**\n       * Set the jitter\n       *\n       * @api public\n       */\n\n      Backoff.prototype.setJitter = function (jitter) {\n        this.jitter = jitter;\n      };\n    }, {}], 9: [function (_dereq_, module, exports) {\n      /*\n       * base64-arraybuffer\n       * https://github.com/niklasvh/base64-arraybuffer\n       *\n       * Copyright (c) 2012 Niklas von Hertzen\n       * Licensed under the MIT license.\n       */\n      (function () {\n        \"use strict\";\n\n        var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n        // Use a lookup table to find the index.\n        var lookup = new Uint8Array(256);\n        for (var i = 0; i < chars.length; i++) {\n          lookup[chars.charCodeAt(i)] = i;\n        }\n\n        exports.encode = function (arraybuffer) {\n          var bytes = new Uint8Array(arraybuffer),\n              i,\n              len = bytes.length,\n              base64 = \"\";\n\n          for (i = 0; i < len; i += 3) {\n            base64 += chars[bytes[i] >> 2];\n            base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n            base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n            base64 += chars[bytes[i + 2] & 63];\n          }\n\n          if (len % 3 === 2) {\n            base64 = base64.substring(0, base64.length - 1) + \"=\";\n          } else if (len % 3 === 1) {\n            base64 = base64.substring(0, base64.length - 2) + \"==\";\n          }\n\n          return base64;\n        };\n\n        exports.decode = function (base64) {\n          var bufferLength = base64.length * 0.75,\n              len = base64.length,\n              i,\n              p = 0,\n              encoded1,\n              encoded2,\n              encoded3,\n              encoded4;\n\n          if (base64[base64.length - 1] === \"=\") {\n            bufferLength--;\n            if (base64[base64.length - 2] === \"=\") {\n              bufferLength--;\n            }\n          }\n\n          var arraybuffer = new ArrayBuffer(bufferLength),\n              bytes = new Uint8Array(arraybuffer);\n\n          for (i = 0; i < len; i += 4) {\n            encoded1 = lookup[base64.charCodeAt(i)];\n            encoded2 = lookup[base64.charCodeAt(i + 1)];\n            encoded3 = lookup[base64.charCodeAt(i + 2)];\n            encoded4 = lookup[base64.charCodeAt(i + 3)];\n\n            bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n          }\n\n          return arraybuffer;\n        };\n      })();\n    }, {}], 10: [function (_dereq_, module, exports) {\n      (function (global) {\n        /**\n         * Create a blob builder even when vendor prefixes exist\n         */\n\n        var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;\n\n        /**\n         * Check if Blob constructor is supported\n         */\n\n        var blobSupported = function () {\n          try {\n            var a = new Blob(['hi']);\n            return a.size === 2;\n          } catch (e) {\n            return false;\n          }\n        }();\n\n        /**\n         * Check if Blob constructor supports ArrayBufferViews\n         * Fails in Safari 6, so we need to map to ArrayBuffers there.\n         */\n\n        var blobSupportsArrayBufferView = blobSupported && function () {\n          try {\n            var b = new Blob([new Uint8Array([1, 2])]);\n            return b.size === 2;\n          } catch (e) {\n            return false;\n          }\n        }();\n\n        /**\n         * Check if BlobBuilder is supported\n         */\n\n        var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;\n\n        /**\n         * Helper function that maps ArrayBufferViews to ArrayBuffers\n         * Used by BlobBuilder constructor and old browsers that didn't\n         * support it in the Blob constructor.\n         */\n\n        function mapArrayBufferViews(ary) {\n          for (var i = 0; i < ary.length; i++) {\n            var chunk = ary[i];\n            if (chunk.buffer instanceof ArrayBuffer) {\n              var buf = chunk.buffer;\n\n              // if this is a subarray, make a copy so we only\n              // include the subarray region from the underlying buffer\n              if (chunk.byteLength !== buf.byteLength) {\n                var copy = new Uint8Array(chunk.byteLength);\n                copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n                buf = copy.buffer;\n              }\n\n              ary[i] = buf;\n            }\n          }\n        }\n\n        function BlobBuilderConstructor(ary, options) {\n          options = options || {};\n\n          var bb = new BlobBuilder();\n          mapArrayBufferViews(ary);\n\n          for (var i = 0; i < ary.length; i++) {\n            bb.append(ary[i]);\n          }\n\n          return options.type ? bb.getBlob(options.type) : bb.getBlob();\n        };\n\n        function BlobConstructor(ary, options) {\n          mapArrayBufferViews(ary);\n          return new Blob(ary, options || {});\n        };\n\n        module.exports = function () {\n          if (blobSupported) {\n            return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n          } else if (blobBuilderSupported) {\n            return BlobBuilderConstructor;\n          } else {\n            return undefined;\n          }\n        }();\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, {}], 11: [function (_dereq_, module, exports) {\n      /**\n       * Slice reference.\n       */\n\n      var slice = [].slice;\n\n      /**\n       * Bind `obj` to `fn`.\n       *\n       * @param {Object} obj\n       * @param {Function|String} fn or string\n       * @return {Function}\n       * @api public\n       */\n\n      module.exports = function (obj, fn) {\n        if ('string' == typeof fn) fn = obj[fn];\n        if ('function' != typeof fn) throw new Error('bind() requires a function');\n        var args = slice.call(arguments, 2);\n        return function () {\n          return fn.apply(obj, args.concat(slice.call(arguments)));\n        };\n      };\n    }, {}], 12: [function (_dereq_, module, exports) {\n\n      /**\n       * Expose `Emitter`.\n       */\n\n      module.exports = Emitter;\n\n      /**\n       * Initialize a new `Emitter`.\n       *\n       * @api public\n       */\n\n      function Emitter(obj) {\n        if (obj) return mixin(obj);\n      };\n\n      /**\n       * Mixin the emitter properties.\n       *\n       * @param {Object} obj\n       * @return {Object}\n       * @api private\n       */\n\n      function mixin(obj) {\n        for (var key in Emitter.prototype) {\n          obj[key] = Emitter.prototype[key];\n        }\n        return obj;\n      }\n\n      /**\n       * Listen on the given `event` with `fn`.\n       *\n       * @param {String} event\n       * @param {Function} fn\n       * @return {Emitter}\n       * @api public\n       */\n\n      Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {\n        this._callbacks = this._callbacks || {};\n        (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);\n        return this;\n      };\n\n      /**\n       * Adds an `event` listener that will be invoked a single\n       * time then automatically removed.\n       *\n       * @param {String} event\n       * @param {Function} fn\n       * @return {Emitter}\n       * @api public\n       */\n\n      Emitter.prototype.once = function (event, fn) {\n        function on() {\n          this.off(event, on);\n          fn.apply(this, arguments);\n        }\n\n        on.fn = fn;\n        this.on(event, on);\n        return this;\n      };\n\n      /**\n       * Remove the given callback for `event` or all\n       * registered callbacks.\n       *\n       * @param {String} event\n       * @param {Function} fn\n       * @return {Emitter}\n       * @api public\n       */\n\n      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {\n        this._callbacks = this._callbacks || {};\n\n        // all\n        if (0 == arguments.length) {\n          this._callbacks = {};\n          return this;\n        }\n\n        // specific event\n        var callbacks = this._callbacks['$' + event];\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (1 == arguments.length) {\n          delete this._callbacks['$' + event];\n          return this;\n        }\n\n        // remove specific handler\n        var cb;\n        for (var i = 0; i < callbacks.length; i++) {\n          cb = callbacks[i];\n          if (cb === fn || cb.fn === fn) {\n            callbacks.splice(i, 1);\n            break;\n          }\n        }\n        return this;\n      };\n\n      /**\n       * Emit `event` with the given args.\n       *\n       * @param {String} event\n       * @param {Mixed} ...\n       * @return {Emitter}\n       */\n\n      Emitter.prototype.emit = function (event) {\n        this._callbacks = this._callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this._callbacks['$' + event];\n\n        if (callbacks) {\n          callbacks = callbacks.slice(0);\n          for (var i = 0, len = callbacks.length; i < len; ++i) {\n            callbacks[i].apply(this, args);\n          }\n        }\n\n        return this;\n      };\n\n      /**\n       * Return array of callbacks for `event`.\n       *\n       * @param {String} event\n       * @return {Array}\n       * @api public\n       */\n\n      Emitter.prototype.listeners = function (event) {\n        this._callbacks = this._callbacks || {};\n        return this._callbacks['$' + event] || [];\n      };\n\n      /**\n       * Check if this emitter has `event` handlers.\n       *\n       * @param {String} event\n       * @return {Boolean}\n       * @api public\n       */\n\n      Emitter.prototype.hasListeners = function (event) {\n        return !!this.listeners(event).length;\n      };\n    }, {}], 13: [function (_dereq_, module, exports) {\n\n      module.exports = function (a, b) {\n        var fn = function fn() {};\n        fn.prototype = b.prototype;\n        a.prototype = new fn();\n        a.prototype.constructor = a;\n      };\n    }, {}], 14: [function (_dereq_, module, exports) {\n\n      /**\n       * This is the web browser implementation of `debug()`.\n       *\n       * Expose `debug()` as the module.\n       */\n\n      exports = module.exports = _dereq_('./debug');\n      exports.log = log;\n      exports.formatArgs = formatArgs;\n      exports.save = save;\n      exports.load = load;\n      exports.useColors = useColors;\n      exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n\n      /**\n       * Colors.\n       */\n\n      exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];\n\n      /**\n       * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n       * and the Firebug extension (any Firefox version) are known\n       * to support \"%c\" CSS customizations.\n       *\n       * TODO: add a `localStorage` variable to explicitly enable/disable colors\n       */\n\n      function useColors() {\n        // is webkit? http://stackoverflow.com/a/16459606/376773\n        return 'WebkitAppearance' in document.documentElement.style ||\n        // is firebug? http://stackoverflow.com/a/398120/376773\n        window.console && (console.firebug || console.exception && console.table) ||\n        // is firefox >= v31?\n        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n        navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31;\n      }\n\n      /**\n       * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n       */\n\n      exports.formatters.j = function (v) {\n        return JSON.stringify(v);\n      };\n\n      /**\n       * Colorize log arguments if enabled.\n       *\n       * @api public\n       */\n\n      function formatArgs() {\n        var args = arguments;\n        var useColors = this.useColors;\n\n        args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n\n        if (!useColors) return args;\n\n        var c = 'color: ' + this.color;\n        args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n        // the final \"%c\" is somewhat tricky, because there could be other\n        // arguments passed either before or after the %c, so we need to\n        // figure out the correct index to insert the CSS into\n        var index = 0;\n        var lastC = 0;\n        args[0].replace(/%[a-z%]/g, function (match) {\n          if ('%%' === match) return;\n          index++;\n          if ('%c' === match) {\n            // we only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n          }\n        });\n\n        args.splice(lastC, 0, c);\n        return args;\n      }\n\n      /**\n       * Invokes `console.log()` when available.\n       * No-op when `console.log` is not a \"function\".\n       *\n       * @api public\n       */\n\n      function log() {\n        // this hackery is required for IE8/9, where\n        // the `console.log` function doesn't have 'apply'\n        return 'object' === (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);\n      }\n\n      /**\n       * Save `namespaces`.\n       *\n       * @param {String} namespaces\n       * @api private\n       */\n\n      function save(namespaces) {\n        try {\n          if (null == namespaces) {\n            exports.storage.removeItem('debug');\n          } else {\n            exports.storage.debug = namespaces;\n          }\n        } catch (e) {}\n      }\n\n      /**\n       * Load `namespaces`.\n       *\n       * @return {String} returns the previously persisted debug modes\n       * @api private\n       */\n\n      function load() {\n        var r;\n        try {\n          r = exports.storage.debug;\n        } catch (e) {}\n        return r;\n      }\n\n      /**\n       * Enable namespaces listed in `localStorage.debug` initially.\n       */\n\n      exports.enable(load());\n\n      /**\n       * Localstorage attempts to return the localstorage.\n       *\n       * This is necessary because safari throws\n       * when a user disables cookies/localstorage\n       * and you attempt to access it.\n       *\n       * @return {LocalStorage}\n       * @api private\n       */\n\n      function localstorage() {\n        try {\n          return window.localStorage;\n        } catch (e) {}\n      }\n    }, { \"./debug\": 15 }], 15: [function (_dereq_, module, exports) {\n\n      /**\n       * This is the common logic for both the Node.js and web browser\n       * implementations of `debug()`.\n       *\n       * Expose `debug()` as the module.\n       */\n\n      exports = module.exports = debug;\n      exports.coerce = coerce;\n      exports.disable = disable;\n      exports.enable = enable;\n      exports.enabled = enabled;\n      exports.humanize = _dereq_('ms');\n\n      /**\n       * The currently active debug mode names, and names to skip.\n       */\n\n      exports.names = [];\n      exports.skips = [];\n\n      /**\n       * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n       *\n       * Valid key names are a single, lowercased letter, i.e. \"n\".\n       */\n\n      exports.formatters = {};\n\n      /**\n       * Previously assigned color.\n       */\n\n      var prevColor = 0;\n\n      /**\n       * Previous log timestamp.\n       */\n\n      var prevTime;\n\n      /**\n       * Select a color.\n       *\n       * @return {Number}\n       * @api private\n       */\n\n      function selectColor() {\n        return exports.colors[prevColor++ % exports.colors.length];\n      }\n\n      /**\n       * Create a debugger with the given `namespace`.\n       *\n       * @param {String} namespace\n       * @return {Function}\n       * @api public\n       */\n\n      function debug(namespace) {\n\n        // define the `disabled` version\n        function disabled() {}\n        disabled.enabled = false;\n\n        // define the `enabled` version\n        function enabled() {\n\n          var self = enabled;\n\n          // set `diff` timestamp\n          var curr = +new Date();\n          var ms = curr - (prevTime || curr);\n          self.diff = ms;\n          self.prev = prevTime;\n          self.curr = curr;\n          prevTime = curr;\n\n          // add the `color` if not set\n          if (null == self.useColors) self.useColors = exports.useColors();\n          if (null == self.color && self.useColors) self.color = selectColor();\n\n          var args = Array.prototype.slice.call(arguments);\n\n          args[0] = exports.coerce(args[0]);\n\n          if ('string' !== typeof args[0]) {\n            // anything else let's inspect with %o\n            args = ['%o'].concat(args);\n          }\n\n          // apply any `formatters` transformations\n          var index = 0;\n          args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {\n            // if we encounter an escaped % then don't increase the array index\n            if (match === '%%') return match;\n            index++;\n            var formatter = exports.formatters[format];\n            if ('function' === typeof formatter) {\n              var val = args[index];\n              match = formatter.call(self, val);\n\n              // now we need to remove `args[index]` since it's inlined in the `format`\n              args.splice(index, 1);\n              index--;\n            }\n            return match;\n          });\n\n          if ('function' === typeof exports.formatArgs) {\n            args = exports.formatArgs.apply(self, args);\n          }\n          var logFn = enabled.log || exports.log || console.log.bind(console);\n          logFn.apply(self, args);\n        }\n        enabled.enabled = true;\n\n        var fn = exports.enabled(namespace) ? enabled : disabled;\n\n        fn.namespace = namespace;\n\n        return fn;\n      }\n\n      /**\n       * Enables a debug mode by namespaces. This can include modes\n       * separated by a colon and wildcards.\n       *\n       * @param {String} namespaces\n       * @api public\n       */\n\n      function enable(namespaces) {\n        exports.save(namespaces);\n\n        var split = (namespaces || '').split(/[\\s,]+/);\n        var len = split.length;\n\n        for (var i = 0; i < len; i++) {\n          if (!split[i]) continue; // ignore empty strings\n          namespaces = split[i].replace(/\\*/g, '.*?');\n          if (namespaces[0] === '-') {\n            exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n          } else {\n            exports.names.push(new RegExp('^' + namespaces + '$'));\n          }\n        }\n      }\n\n      /**\n       * Disable debug output.\n       *\n       * @api public\n       */\n\n      function disable() {\n        exports.enable('');\n      }\n\n      /**\n       * Returns true if the given mode name is enabled, false otherwise.\n       *\n       * @param {String} name\n       * @return {Boolean}\n       * @api public\n       */\n\n      function enabled(name) {\n        var i, len;\n        for (i = 0, len = exports.skips.length; i < len; i++) {\n          if (exports.skips[i].test(name)) {\n            return false;\n          }\n        }\n        for (i = 0, len = exports.names.length; i < len; i++) {\n          if (exports.names[i].test(name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Coerce `val`.\n       *\n       * @param {Mixed} val\n       * @return {Mixed}\n       * @api private\n       */\n\n      function coerce(val) {\n        if (val instanceof Error) return val.stack || val.message;\n        return val;\n      }\n    }, { \"ms\": 35 }], 16: [function (_dereq_, module, exports) {\n\n      module.exports = _dereq_('./lib/');\n    }, { \"./lib/\": 17 }], 17: [function (_dereq_, module, exports) {\n\n      module.exports = _dereq_('./socket');\n\n      /**\n       * Exports parser\n       *\n       * @api public\n       *\n       */\n      module.exports.parser = _dereq_('engine.io-parser');\n    }, { \"./socket\": 18, \"engine.io-parser\": 27 }], 18: [function (_dereq_, module, exports) {\n      (function (global) {\n        /**\n         * Module dependencies.\n         */\n\n        var transports = _dereq_('./transports');\n        var Emitter = _dereq_('component-emitter');\n        var debug = _dereq_('debug')('engine.io-client:socket');\n        var index = _dereq_('indexof');\n        var parser = _dereq_('engine.io-parser');\n        var parseuri = _dereq_('parseuri');\n        var parsejson = _dereq_('parsejson');\n        var parseqs = _dereq_('parseqs');\n\n        /**\n         * Module exports.\n         */\n\n        module.exports = Socket;\n\n        /**\n         * Noop function.\n         *\n         * @api private\n         */\n\n        function noop() {}\n\n        /**\n         * Socket constructor.\n         *\n         * @param {String|Object} uri or options\n         * @param {Object} options\n         * @api public\n         */\n\n        function Socket(uri, opts) {\n          if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n          opts = opts || {};\n\n          if (uri && 'object' == (typeof uri === \"undefined\" ? \"undefined\" : _typeof(uri))) {\n            opts = uri;\n            uri = null;\n          }\n\n          if (uri) {\n            uri = parseuri(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';\n            opts.port = uri.port;\n            if (uri.query) opts.query = uri.query;\n          } else if (opts.host) {\n            opts.hostname = parseuri(opts.host).host;\n          }\n\n          this.secure = null != opts.secure ? opts.secure : global.location && 'https:' == location.protocol;\n\n          if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? '443' : '80';\n          }\n\n          this.agent = opts.agent || false;\n          this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');\n          this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80);\n          this.query = opts.query || {};\n          if ('string' == typeof this.query) this.query = parseqs.decode(this.query);\n          this.upgrade = false !== opts.upgrade;\n          this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n          this.forceJSONP = !!opts.forceJSONP;\n          this.jsonp = false !== opts.jsonp;\n          this.forceBase64 = !!opts.forceBase64;\n          this.enablesXDR = !!opts.enablesXDR;\n          this.timestampParam = opts.timestampParam || 't';\n          this.timestampRequests = opts.timestampRequests;\n          this.transports = opts.transports || ['polling', 'websocket'];\n          this.readyState = '';\n          this.writeBuffer = [];\n          this.policyPort = opts.policyPort || 843;\n          this.rememberUpgrade = opts.rememberUpgrade || false;\n          this.binaryType = null;\n          this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n          this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;\n\n          if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n          if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n            this.perMessageDeflate.threshold = 1024;\n          }\n\n          // SSL options for Node.js client\n          this.pfx = opts.pfx || null;\n          this.key = opts.key || null;\n          this.passphrase = opts.passphrase || null;\n          this.cert = opts.cert || null;\n          this.ca = opts.ca || null;\n          this.ciphers = opts.ciphers || null;\n          this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;\n\n          // other options for Node.js client\n          var freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global;\n          if (freeGlobal.global === freeGlobal) {\n            if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n              this.extraHeaders = opts.extraHeaders;\n            }\n          }\n\n          this.open();\n        }\n\n        Socket.priorWebsocketSuccess = false;\n\n        /**\n         * Mix in `Emitter`.\n         */\n\n        Emitter(Socket.prototype);\n\n        /**\n         * Protocol version.\n         *\n         * @api public\n         */\n\n        Socket.protocol = parser.protocol; // this is an int\n\n        /**\n         * Expose deps for legacy compatibility\n         * and standalone browser access.\n         */\n\n        Socket.Socket = Socket;\n        Socket.Transport = _dereq_('./transport');\n        Socket.transports = _dereq_('./transports');\n        Socket.parser = _dereq_('engine.io-parser');\n\n        /**\n         * Creates transport of the given type.\n         *\n         * @param {String} transport name\n         * @return {Transport}\n         * @api private\n         */\n\n        Socket.prototype.createTransport = function (name) {\n          debug('creating transport \"%s\"', name);\n          var query = clone(this.query);\n\n          // append engine.io protocol identifier\n          query.EIO = parser.protocol;\n\n          // transport name\n          query.transport = name;\n\n          // session id if we already have one\n          if (this.id) query.sid = this.id;\n\n          var transport = new transports[name]({\n            agent: this.agent,\n            hostname: this.hostname,\n            port: this.port,\n            secure: this.secure,\n            path: this.path,\n            query: query,\n            forceJSONP: this.forceJSONP,\n            jsonp: this.jsonp,\n            forceBase64: this.forceBase64,\n            enablesXDR: this.enablesXDR,\n            timestampRequests: this.timestampRequests,\n            timestampParam: this.timestampParam,\n            policyPort: this.policyPort,\n            socket: this,\n            pfx: this.pfx,\n            key: this.key,\n            passphrase: this.passphrase,\n            cert: this.cert,\n            ca: this.ca,\n            ciphers: this.ciphers,\n            rejectUnauthorized: this.rejectUnauthorized,\n            perMessageDeflate: this.perMessageDeflate,\n            extraHeaders: this.extraHeaders\n          });\n\n          return transport;\n        };\n\n        function clone(obj) {\n          var o = {};\n          for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n              o[i] = obj[i];\n            }\n          }\n          return o;\n        }\n\n        /**\n         * Initializes transport to use and starts probe.\n         *\n         * @api private\n         */\n        Socket.prototype.open = function () {\n          var transport;\n          if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {\n            transport = 'websocket';\n          } else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            var self = this;\n            setTimeout(function () {\n              self.emit('error', 'No transports available');\n            }, 0);\n            return;\n          } else {\n            transport = this.transports[0];\n          }\n          this.readyState = 'opening';\n\n          // Retry with the next transport if the transport is disabled (jsonp: false)\n          try {\n            transport = this.createTransport(transport);\n          } catch (e) {\n            this.transports.shift();\n            this.open();\n            return;\n          }\n\n          transport.open();\n          this.setTransport(transport);\n        };\n\n        /**\n         * Sets the current transport. Disables the existing one (if any).\n         *\n         * @api private\n         */\n\n        Socket.prototype.setTransport = function (transport) {\n          debug('setting transport %s', transport.name);\n          var self = this;\n\n          if (this.transport) {\n            debug('clearing existing transport %s', this.transport.name);\n            this.transport.removeAllListeners();\n          }\n\n          // set up transport\n          this.transport = transport;\n\n          // set up transport listeners\n          transport.on('drain', function () {\n            self.onDrain();\n          }).on('packet', function (packet) {\n            self.onPacket(packet);\n          }).on('error', function (e) {\n            self.onError(e);\n          }).on('close', function () {\n            self.onClose('transport close');\n          });\n        };\n\n        /**\n         * Probes a transport.\n         *\n         * @param {String} transport name\n         * @api private\n         */\n\n        Socket.prototype.probe = function (name) {\n          debug('probing transport \"%s\"', name);\n          var transport = this.createTransport(name, { probe: 1 }),\n              failed = false,\n              self = this;\n\n          Socket.priorWebsocketSuccess = false;\n\n          function onTransportOpen() {\n            if (self.onlyBinaryUpgrades) {\n              var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n              failed = failed || upgradeLosesBinary;\n            }\n            if (failed) return;\n\n            debug('probe transport \"%s\" opened', name);\n            transport.send([{ type: 'ping', data: 'probe' }]);\n            transport.once('packet', function (msg) {\n              if (failed) return;\n              if ('pong' == msg.type && 'probe' == msg.data) {\n                debug('probe transport \"%s\" pong', name);\n                self.upgrading = true;\n                self.emit('upgrading', transport);\n                if (!transport) return;\n                Socket.priorWebsocketSuccess = 'websocket' == transport.name;\n\n                debug('pausing current transport \"%s\"', self.transport.name);\n                self.transport.pause(function () {\n                  if (failed) return;\n                  if ('closed' == self.readyState) return;\n                  debug('changing transport and sending upgrade packet');\n\n                  cleanup();\n\n                  self.setTransport(transport);\n                  transport.send([{ type: 'upgrade' }]);\n                  self.emit('upgrade', transport);\n                  transport = null;\n                  self.upgrading = false;\n                  self.flush();\n                });\n              } else {\n                debug('probe transport \"%s\" failed', name);\n                var err = new Error('probe error');\n                err.transport = transport.name;\n                self.emit('upgradeError', err);\n              }\n            });\n          }\n\n          function freezeTransport() {\n            if (failed) return;\n\n            // Any callback called by transport should be ignored since now\n            failed = true;\n\n            cleanup();\n\n            transport.close();\n            transport = null;\n          }\n\n          //Handle any error that happens while probing\n          function onerror(err) {\n            var error = new Error('probe error: ' + err);\n            error.transport = transport.name;\n\n            freezeTransport();\n\n            debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n            self.emit('upgradeError', error);\n          }\n\n          function onTransportClose() {\n            onerror(\"transport closed\");\n          }\n\n          //When the socket is closed while we're probing\n          function onclose() {\n            onerror(\"socket closed\");\n          }\n\n          //When the socket is upgraded while we're probing\n          function onupgrade(to) {\n            if (transport && to.name != transport.name) {\n              debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n              freezeTransport();\n            }\n          }\n\n          //Remove all listeners on the transport and on self\n          function cleanup() {\n            transport.removeListener('open', onTransportOpen);\n            transport.removeListener('error', onerror);\n            transport.removeListener('close', onTransportClose);\n            self.removeListener('close', onclose);\n            self.removeListener('upgrading', onupgrade);\n          }\n\n          transport.once('open', onTransportOpen);\n          transport.once('error', onerror);\n          transport.once('close', onTransportClose);\n\n          this.once('close', onclose);\n          this.once('upgrading', onupgrade);\n\n          transport.open();\n        };\n\n        /**\n         * Called when connection is deemed open.\n         *\n         * @api public\n         */\n\n        Socket.prototype.onOpen = function () {\n          debug('socket open');\n          this.readyState = 'open';\n          Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;\n          this.emit('open');\n          this.flush();\n\n          // we check for `readyState` in case an `open`\n          // listener already closed the socket\n          if ('open' == this.readyState && this.upgrade && this.transport.pause) {\n            debug('starting upgrade probes');\n            for (var i = 0, l = this.upgrades.length; i < l; i++) {\n              this.probe(this.upgrades[i]);\n            }\n          }\n        };\n\n        /**\n         * Handles a packet.\n         *\n         * @api private\n         */\n\n        Socket.prototype.onPacket = function (packet) {\n          if ('opening' == this.readyState || 'open' == this.readyState) {\n            debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n            this.emit('packet', packet);\n\n            // Socket is live - any packet counts\n            this.emit('heartbeat');\n\n            switch (packet.type) {\n              case 'open':\n                this.onHandshake(parsejson(packet.data));\n                break;\n\n              case 'pong':\n                this.setPing();\n                this.emit('pong');\n                break;\n\n              case 'error':\n                var err = new Error('server error');\n                err.code = packet.data;\n                this.onError(err);\n                break;\n\n              case 'message':\n                this.emit('data', packet.data);\n                this.emit('message', packet.data);\n                break;\n            }\n          } else {\n            debug('packet received with socket readyState \"%s\"', this.readyState);\n          }\n        };\n\n        /**\n         * Called upon handshake completion.\n         *\n         * @param {Object} handshake obj\n         * @api private\n         */\n\n        Socket.prototype.onHandshake = function (data) {\n          this.emit('handshake', data);\n          this.id = data.sid;\n          this.transport.query.sid = data.sid;\n          this.upgrades = this.filterUpgrades(data.upgrades);\n          this.pingInterval = data.pingInterval;\n          this.pingTimeout = data.pingTimeout;\n          this.onOpen();\n          // In case open handler closes socket\n          if ('closed' == this.readyState) return;\n          this.setPing();\n\n          // Prolong liveness of socket on heartbeat\n          this.removeListener('heartbeat', this.onHeartbeat);\n          this.on('heartbeat', this.onHeartbeat);\n        };\n\n        /**\n         * Resets ping timeout.\n         *\n         * @api private\n         */\n\n        Socket.prototype.onHeartbeat = function (timeout) {\n          clearTimeout(this.pingTimeoutTimer);\n          var self = this;\n          self.pingTimeoutTimer = setTimeout(function () {\n            if ('closed' == self.readyState) return;\n            self.onClose('ping timeout');\n          }, timeout || self.pingInterval + self.pingTimeout);\n        };\n\n        /**\n         * Pings server every `this.pingInterval` and expects response\n         * within `this.pingTimeout` or closes connection.\n         *\n         * @api private\n         */\n\n        Socket.prototype.setPing = function () {\n          var self = this;\n          clearTimeout(self.pingIntervalTimer);\n          self.pingIntervalTimer = setTimeout(function () {\n            debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n            self.ping();\n            self.onHeartbeat(self.pingTimeout);\n          }, self.pingInterval);\n        };\n\n        /**\n        * Sends a ping packet.\n        *\n        * @api private\n        */\n\n        Socket.prototype.ping = function () {\n          var self = this;\n          this.sendPacket('ping', function () {\n            self.emit('ping');\n          });\n        };\n\n        /**\n         * Called on `drain` event\n         *\n         * @api private\n         */\n\n        Socket.prototype.onDrain = function () {\n          this.writeBuffer.splice(0, this.prevBufferLen);\n\n          // setting prevBufferLen = 0 is very important\n          // for example, when upgrading, upgrade packet is sent over,\n          // and a nonzero prevBufferLen could cause problems on `drain`\n          this.prevBufferLen = 0;\n\n          if (0 === this.writeBuffer.length) {\n            this.emit('drain');\n          } else {\n            this.flush();\n          }\n        };\n\n        /**\n         * Flush write buffers.\n         *\n         * @api private\n         */\n\n        Socket.prototype.flush = function () {\n          if ('closed' != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n            debug('flushing %d packets in socket', this.writeBuffer.length);\n            this.transport.send(this.writeBuffer);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = this.writeBuffer.length;\n            this.emit('flush');\n          }\n        };\n\n        /**\n         * Sends a message.\n         *\n         * @param {String} message.\n         * @param {Function} callback function.\n         * @param {Object} options.\n         * @return {Socket} for chaining.\n         * @api public\n         */\n\n        Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {\n          this.sendPacket('message', msg, options, fn);\n          return this;\n        };\n\n        /**\n         * Sends a packet.\n         *\n         * @param {String} packet type.\n         * @param {String} data.\n         * @param {Object} options.\n         * @param {Function} callback function.\n         * @api private\n         */\n\n        Socket.prototype.sendPacket = function (type, data, options, fn) {\n          if ('function' == typeof data) {\n            fn = data;\n            data = undefined;\n          }\n\n          if ('function' == typeof options) {\n            fn = options;\n            options = null;\n          }\n\n          if ('closing' == this.readyState || 'closed' == this.readyState) {\n            return;\n          }\n\n          options = options || {};\n          options.compress = false !== options.compress;\n\n          var packet = {\n            type: type,\n            data: data,\n            options: options\n          };\n          this.emit('packetCreate', packet);\n          this.writeBuffer.push(packet);\n          if (fn) this.once('flush', fn);\n          this.flush();\n        };\n\n        /**\n         * Closes the connection.\n         *\n         * @api private\n         */\n\n        Socket.prototype.close = function () {\n          if ('opening' == this.readyState || 'open' == this.readyState) {\n            this.readyState = 'closing';\n\n            var self = this;\n\n            if (this.writeBuffer.length) {\n              this.once('drain', function () {\n                if (this.upgrading) {\n                  waitForUpgrade();\n                } else {\n                  close();\n                }\n              });\n            } else if (this.upgrading) {\n              waitForUpgrade();\n            } else {\n              close();\n            }\n          }\n\n          function close() {\n            self.onClose('forced close');\n            debug('socket closing - telling transport to close');\n            self.transport.close();\n          }\n\n          function cleanupAndClose() {\n            self.removeListener('upgrade', cleanupAndClose);\n            self.removeListener('upgradeError', cleanupAndClose);\n            close();\n          }\n\n          function waitForUpgrade() {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            self.once('upgrade', cleanupAndClose);\n            self.once('upgradeError', cleanupAndClose);\n          }\n\n          return this;\n        };\n\n        /**\n         * Called upon transport error\n         *\n         * @api private\n         */\n\n        Socket.prototype.onError = function (err) {\n          debug('socket error %j', err);\n          Socket.priorWebsocketSuccess = false;\n          this.emit('error', err);\n          this.onClose('transport error', err);\n        };\n\n        /**\n         * Called upon transport close.\n         *\n         * @api private\n         */\n\n        Socket.prototype.onClose = function (reason, desc) {\n          if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {\n            debug('socket close with reason: \"%s\"', reason);\n            var self = this;\n\n            // clear timers\n            clearTimeout(this.pingIntervalTimer);\n            clearTimeout(this.pingTimeoutTimer);\n\n            // stop event from firing again for transport\n            this.transport.removeAllListeners('close');\n\n            // ensure transport won't stay open\n            this.transport.close();\n\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n\n            // set ready state\n            this.readyState = 'closed';\n\n            // clear session id\n            this.id = null;\n\n            // emit close event\n            this.emit('close', reason, desc);\n\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            self.writeBuffer = [];\n            self.prevBufferLen = 0;\n          }\n        };\n\n        /**\n         * Filters upgrades, returning only those matching client transports.\n         *\n         * @param {Array} server upgrades\n         * @api private\n         *\n         */\n\n        Socket.prototype.filterUpgrades = function (upgrades) {\n          var filteredUpgrades = [];\n          for (var i = 0, j = upgrades.length; i < j; i++) {\n            if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n          }\n          return filteredUpgrades;\n        };\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"./transport\": 19, \"./transports\": 20, \"component-emitter\": 26, \"debug\": 14, \"engine.io-parser\": 27, \"indexof\": 32, \"parsejson\": 36, \"parseqs\": 37, \"parseuri\": 38 }], 19: [function (_dereq_, module, exports) {\n      /**\n       * Module dependencies.\n       */\n\n      var parser = _dereq_('engine.io-parser');\n      var Emitter = _dereq_('component-emitter');\n\n      /**\n       * Module exports.\n       */\n\n      module.exports = Transport;\n\n      /**\n       * Transport abstract constructor.\n       *\n       * @param {Object} options.\n       * @api private\n       */\n\n      function Transport(opts) {\n        this.path = opts.path;\n        this.hostname = opts.hostname;\n        this.port = opts.port;\n        this.secure = opts.secure;\n        this.query = opts.query;\n        this.timestampParam = opts.timestampParam;\n        this.timestampRequests = opts.timestampRequests;\n        this.readyState = '';\n        this.agent = opts.agent || false;\n        this.socket = opts.socket;\n        this.enablesXDR = opts.enablesXDR;\n\n        // SSL options for Node.js client\n        this.pfx = opts.pfx;\n        this.key = opts.key;\n        this.passphrase = opts.passphrase;\n        this.cert = opts.cert;\n        this.ca = opts.ca;\n        this.ciphers = opts.ciphers;\n        this.rejectUnauthorized = opts.rejectUnauthorized;\n\n        // other options for Node.js client\n        this.extraHeaders = opts.extraHeaders;\n      }\n\n      /**\n       * Mix in `Emitter`.\n       */\n\n      Emitter(Transport.prototype);\n\n      /**\n       * Emits an error.\n       *\n       * @param {String} str\n       * @return {Transport} for chaining\n       * @api public\n       */\n\n      Transport.prototype.onError = function (msg, desc) {\n        var err = new Error(msg);\n        err.type = 'TransportError';\n        err.description = desc;\n        this.emit('error', err);\n        return this;\n      };\n\n      /**\n       * Opens the transport.\n       *\n       * @api public\n       */\n\n      Transport.prototype.open = function () {\n        if ('closed' == this.readyState || '' == this.readyState) {\n          this.readyState = 'opening';\n          this.doOpen();\n        }\n\n        return this;\n      };\n\n      /**\n       * Closes the transport.\n       *\n       * @api private\n       */\n\n      Transport.prototype.close = function () {\n        if ('opening' == this.readyState || 'open' == this.readyState) {\n          this.doClose();\n          this.onClose();\n        }\n\n        return this;\n      };\n\n      /**\n       * Sends multiple packets.\n       *\n       * @param {Array} packets\n       * @api private\n       */\n\n      Transport.prototype.send = function (packets) {\n        if ('open' == this.readyState) {\n          this.write(packets);\n        } else {\n          throw new Error('Transport not open');\n        }\n      };\n\n      /**\n       * Called upon open\n       *\n       * @api private\n       */\n\n      Transport.prototype.onOpen = function () {\n        this.readyState = 'open';\n        this.writable = true;\n        this.emit('open');\n      };\n\n      /**\n       * Called with data.\n       *\n       * @param {String} data\n       * @api private\n       */\n\n      Transport.prototype.onData = function (data) {\n        var packet = parser.decodePacket(data, this.socket.binaryType);\n        this.onPacket(packet);\n      };\n\n      /**\n       * Called with a decoded packet.\n       */\n\n      Transport.prototype.onPacket = function (packet) {\n        this.emit('packet', packet);\n      };\n\n      /**\n       * Called upon close.\n       *\n       * @api private\n       */\n\n      Transport.prototype.onClose = function () {\n        this.readyState = 'closed';\n        this.emit('close');\n      };\n    }, { \"component-emitter\": 26, \"engine.io-parser\": 27 }], 20: [function (_dereq_, module, exports) {\n      (function (global) {\n        /**\n         * Module dependencies\n         */\n\n        var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');\n        var XHR = _dereq_('./polling-xhr');\n        var JSONP = _dereq_('./polling-jsonp');\n        var websocket = _dereq_('./websocket');\n\n        /**\n         * Export transports.\n         */\n\n        exports.polling = polling;\n        exports.websocket = websocket;\n\n        /**\n         * Polling transport polymorphic constructor.\n         * Decides on xhr vs jsonp based on feature detection.\n         *\n         * @api private\n         */\n\n        function polling(opts) {\n          var xhr;\n          var xd = false;\n          var xs = false;\n          var jsonp = false !== opts.jsonp;\n\n          if (global.location) {\n            var isSSL = 'https:' == location.protocol;\n            var port = location.port;\n\n            // some user agents have empty `location.port`\n            if (!port) {\n              port = isSSL ? 443 : 80;\n            }\n\n            xd = opts.hostname != location.hostname || port != opts.port;\n            xs = opts.secure != isSSL;\n          }\n\n          opts.xdomain = xd;\n          opts.xscheme = xs;\n          xhr = new XMLHttpRequest(opts);\n\n          if ('open' in xhr && !opts.forceJSONP) {\n            return new XHR(opts);\n          } else {\n            if (!jsonp) throw new Error('JSONP disabled');\n            return new JSONP(opts);\n          }\n        }\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"./polling-jsonp\": 21, \"./polling-xhr\": 22, \"./websocket\": 24, \"xmlhttprequest-ssl\": 25 }], 21: [function (_dereq_, module, exports) {\n      (function (global) {\n\n        /**\n         * Module requirements.\n         */\n\n        var Polling = _dereq_('./polling');\n        var inherit = _dereq_('component-inherit');\n\n        /**\n         * Module exports.\n         */\n\n        module.exports = JSONPPolling;\n\n        /**\n         * Cached regular expressions.\n         */\n\n        var rNewline = /\\n/g;\n        var rEscapedNewline = /\\\\n/g;\n\n        /**\n         * Global JSONP callbacks.\n         */\n\n        var callbacks;\n\n        /**\n         * Callbacks count.\n         */\n\n        var index = 0;\n\n        /**\n         * Noop.\n         */\n\n        function empty() {}\n\n        /**\n         * JSONP Polling constructor.\n         *\n         * @param {Object} opts.\n         * @api public\n         */\n\n        function JSONPPolling(opts) {\n          Polling.call(this, opts);\n\n          this.query = this.query || {};\n\n          // define global callbacks array if not present\n          // we do this here (lazily) to avoid unneeded global pollution\n          if (!callbacks) {\n            // we need to consider multiple engines in the same page\n            if (!global.___eio) global.___eio = [];\n            callbacks = global.___eio;\n          }\n\n          // callback identifier\n          this.index = callbacks.length;\n\n          // add callback to jsonp global\n          var self = this;\n          callbacks.push(function (msg) {\n            self.onData(msg);\n          });\n\n          // append to query string\n          this.query.j = this.index;\n\n          // prevent spurious errors from being emitted when the window is unloaded\n          if (global.document && global.addEventListener) {\n            global.addEventListener('beforeunload', function () {\n              if (self.script) self.script.onerror = empty;\n            }, false);\n          }\n        }\n\n        /**\n         * Inherits from Polling.\n         */\n\n        inherit(JSONPPolling, Polling);\n\n        /*\n         * JSONP only supports binary as base64 encoded strings\n         */\n\n        JSONPPolling.prototype.supportsBinary = false;\n\n        /**\n         * Closes the socket.\n         *\n         * @api private\n         */\n\n        JSONPPolling.prototype.doClose = function () {\n          if (this.script) {\n            this.script.parentNode.removeChild(this.script);\n            this.script = null;\n          }\n\n          if (this.form) {\n            this.form.parentNode.removeChild(this.form);\n            this.form = null;\n            this.iframe = null;\n          }\n\n          Polling.prototype.doClose.call(this);\n        };\n\n        /**\n         * Starts a poll cycle.\n         *\n         * @api private\n         */\n\n        JSONPPolling.prototype.doPoll = function () {\n          var self = this;\n          var script = document.createElement('script');\n\n          if (this.script) {\n            this.script.parentNode.removeChild(this.script);\n            this.script = null;\n          }\n\n          script.async = true;\n          script.src = this.uri();\n          script.onerror = function (e) {\n            self.onError('jsonp poll error', e);\n          };\n\n          var insertAt = document.getElementsByTagName('script')[0];\n          if (insertAt) {\n            insertAt.parentNode.insertBefore(script, insertAt);\n          } else {\n            (document.head || document.body).appendChild(script);\n          }\n          this.script = script;\n\n          var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);\n\n          if (isUAgecko) {\n            setTimeout(function () {\n              var iframe = document.createElement('iframe');\n              document.body.appendChild(iframe);\n              document.body.removeChild(iframe);\n            }, 100);\n          }\n        };\n\n        /**\n         * Writes with a hidden iframe.\n         *\n         * @param {String} data to send\n         * @param {Function} called upon flush.\n         * @api private\n         */\n\n        JSONPPolling.prototype.doWrite = function (data, fn) {\n          var self = this;\n\n          if (!this.form) {\n            var form = document.createElement('form');\n            var area = document.createElement('textarea');\n            var id = this.iframeId = 'eio_iframe_' + this.index;\n            var iframe;\n\n            form.className = 'socketio';\n            form.style.position = 'absolute';\n            form.style.top = '-1000px';\n            form.style.left = '-1000px';\n            form.target = id;\n            form.method = 'POST';\n            form.setAttribute('accept-charset', 'utf-8');\n            area.name = 'd';\n            form.appendChild(area);\n            document.body.appendChild(form);\n\n            this.form = form;\n            this.area = area;\n          }\n\n          this.form.action = this.uri();\n\n          function complete() {\n            initIframe();\n            fn();\n          }\n\n          function initIframe() {\n            if (self.iframe) {\n              try {\n                self.form.removeChild(self.iframe);\n              } catch (e) {\n                self.onError('jsonp polling iframe removal error', e);\n              }\n            }\n\n            try {\n              // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n              var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n              iframe = document.createElement(html);\n            } catch (e) {\n              iframe = document.createElement('iframe');\n              iframe.name = self.iframeId;\n              iframe.src = 'javascript:0';\n            }\n\n            iframe.id = self.iframeId;\n\n            self.form.appendChild(iframe);\n            self.iframe = iframe;\n          }\n\n          initIframe();\n\n          // escape \\n to prevent it from being converted into \\r\\n by some UAs\n          // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n          data = data.replace(rEscapedNewline, '\\\\\\n');\n          this.area.value = data.replace(rNewline, '\\\\n');\n\n          try {\n            this.form.submit();\n          } catch (e) {}\n\n          if (this.iframe.attachEvent) {\n            this.iframe.onreadystatechange = function () {\n              if (self.iframe.readyState == 'complete') {\n                complete();\n              }\n            };\n          } else {\n            this.iframe.onload = complete;\n          }\n        };\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"./polling\": 23, \"component-inherit\": 13 }], 22: [function (_dereq_, module, exports) {\n      (function (global) {\n        /**\n         * Module requirements.\n         */\n\n        var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');\n        var Polling = _dereq_('./polling');\n        var Emitter = _dereq_('component-emitter');\n        var inherit = _dereq_('component-inherit');\n        var debug = _dereq_('debug')('engine.io-client:polling-xhr');\n\n        /**\n         * Module exports.\n         */\n\n        module.exports = XHR;\n        module.exports.Request = Request;\n\n        /**\n         * Empty function\n         */\n\n        function empty() {}\n\n        /**\n         * XHR Polling constructor.\n         *\n         * @param {Object} opts\n         * @api public\n         */\n\n        function XHR(opts) {\n          Polling.call(this, opts);\n\n          if (global.location) {\n            var isSSL = 'https:' == location.protocol;\n            var port = location.port;\n\n            // some user agents have empty `location.port`\n            if (!port) {\n              port = isSSL ? 443 : 80;\n            }\n\n            this.xd = opts.hostname != global.location.hostname || port != opts.port;\n            this.xs = opts.secure != isSSL;\n          } else {\n            this.extraHeaders = opts.extraHeaders;\n          }\n        }\n\n        /**\n         * Inherits from Polling.\n         */\n\n        inherit(XHR, Polling);\n\n        /**\n         * XHR supports binary\n         */\n\n        XHR.prototype.supportsBinary = true;\n\n        /**\n         * Creates a request.\n         *\n         * @param {String} method\n         * @api private\n         */\n\n        XHR.prototype.request = function (opts) {\n          opts = opts || {};\n          opts.uri = this.uri();\n          opts.xd = this.xd;\n          opts.xs = this.xs;\n          opts.agent = this.agent || false;\n          opts.supportsBinary = this.supportsBinary;\n          opts.enablesXDR = this.enablesXDR;\n\n          // SSL options for Node.js client\n          opts.pfx = this.pfx;\n          opts.key = this.key;\n          opts.passphrase = this.passphrase;\n          opts.cert = this.cert;\n          opts.ca = this.ca;\n          opts.ciphers = this.ciphers;\n          opts.rejectUnauthorized = this.rejectUnauthorized;\n\n          // other options for Node.js client\n          opts.extraHeaders = this.extraHeaders;\n\n          return new Request(opts);\n        };\n\n        /**\n         * Sends data.\n         *\n         * @param {String} data to send.\n         * @param {Function} called upon flush.\n         * @api private\n         */\n\n        XHR.prototype.doWrite = function (data, fn) {\n          var isBinary = typeof data !== 'string' && data !== undefined;\n          var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n          var self = this;\n          req.on('success', fn);\n          req.on('error', function (err) {\n            self.onError('xhr post error', err);\n          });\n          this.sendXhr = req;\n        };\n\n        /**\n         * Starts a poll cycle.\n         *\n         * @api private\n         */\n\n        XHR.prototype.doPoll = function () {\n          debug('xhr poll');\n          var req = this.request();\n          var self = this;\n          req.on('data', function (data) {\n            self.onData(data);\n          });\n          req.on('error', function (err) {\n            self.onError('xhr poll error', err);\n          });\n          this.pollXhr = req;\n        };\n\n        /**\n         * Request constructor\n         *\n         * @param {Object} options\n         * @api public\n         */\n\n        function Request(opts) {\n          this.method = opts.method || 'GET';\n          this.uri = opts.uri;\n          this.xd = !!opts.xd;\n          this.xs = !!opts.xs;\n          this.async = false !== opts.async;\n          this.data = undefined != opts.data ? opts.data : null;\n          this.agent = opts.agent;\n          this.isBinary = opts.isBinary;\n          this.supportsBinary = opts.supportsBinary;\n          this.enablesXDR = opts.enablesXDR;\n\n          // SSL options for Node.js client\n          this.pfx = opts.pfx;\n          this.key = opts.key;\n          this.passphrase = opts.passphrase;\n          this.cert = opts.cert;\n          this.ca = opts.ca;\n          this.ciphers = opts.ciphers;\n          this.rejectUnauthorized = opts.rejectUnauthorized;\n\n          // other options for Node.js client\n          this.extraHeaders = opts.extraHeaders;\n\n          this.create();\n        }\n\n        /**\n         * Mix in `Emitter`.\n         */\n\n        Emitter(Request.prototype);\n\n        /**\n         * Creates the XHR object and sends the request.\n         *\n         * @api private\n         */\n\n        Request.prototype.create = function () {\n          var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n          // SSL options for Node.js client\n          opts.pfx = this.pfx;\n          opts.key = this.key;\n          opts.passphrase = this.passphrase;\n          opts.cert = this.cert;\n          opts.ca = this.ca;\n          opts.ciphers = this.ciphers;\n          opts.rejectUnauthorized = this.rejectUnauthorized;\n\n          var xhr = this.xhr = new XMLHttpRequest(opts);\n          var self = this;\n\n          try {\n            debug('xhr open %s: %s', this.method, this.uri);\n            xhr.open(this.method, this.uri, this.async);\n            try {\n              if (this.extraHeaders) {\n                xhr.setDisableHeaderCheck(true);\n                for (var i in this.extraHeaders) {\n                  if (this.extraHeaders.hasOwnProperty(i)) {\n                    xhr.setRequestHeader(i, this.extraHeaders[i]);\n                  }\n                }\n              }\n            } catch (e) {}\n            if (this.supportsBinary) {\n              // This has to be done after open because Firefox is stupid\n              // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n              xhr.responseType = 'arraybuffer';\n            }\n\n            if ('POST' == this.method) {\n              try {\n                if (this.isBinary) {\n                  xhr.setRequestHeader('Content-type', 'application/octet-stream');\n                } else {\n                  xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n                }\n              } catch (e) {}\n            }\n\n            // ie6 check\n            if ('withCredentials' in xhr) {\n              xhr.withCredentials = true;\n            }\n\n            if (this.hasXDR()) {\n              xhr.onload = function () {\n                self.onLoad();\n              };\n              xhr.onerror = function () {\n                self.onError(xhr.responseText);\n              };\n            } else {\n              xhr.onreadystatechange = function () {\n                if (4 != xhr.readyState) return;\n                if (200 == xhr.status || 1223 == xhr.status) {\n                  self.onLoad();\n                } else {\n                  // make sure the `error` event handler that's user-set\n                  // does not throw in the same tick and gets caught here\n                  setTimeout(function () {\n                    self.onError(xhr.status);\n                  }, 0);\n                }\n              };\n            }\n\n            debug('xhr data %s', this.data);\n            xhr.send(this.data);\n          } catch (e) {\n            // Need to defer since .create() is called directly fhrom the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            setTimeout(function () {\n              self.onError(e);\n            }, 0);\n            return;\n          }\n\n          if (global.document) {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n          }\n        };\n\n        /**\n         * Called upon successful response.\n         *\n         * @api private\n         */\n\n        Request.prototype.onSuccess = function () {\n          this.emit('success');\n          this.cleanup();\n        };\n\n        /**\n         * Called if we have data.\n         *\n         * @api private\n         */\n\n        Request.prototype.onData = function (data) {\n          this.emit('data', data);\n          this.onSuccess();\n        };\n\n        /**\n         * Called upon error.\n         *\n         * @api private\n         */\n\n        Request.prototype.onError = function (err) {\n          this.emit('error', err);\n          this.cleanup(true);\n        };\n\n        /**\n         * Cleans up house.\n         *\n         * @api private\n         */\n\n        Request.prototype.cleanup = function (fromError) {\n          if ('undefined' == typeof this.xhr || null === this.xhr) {\n            return;\n          }\n          // xmlhttprequest\n          if (this.hasXDR()) {\n            this.xhr.onload = this.xhr.onerror = empty;\n          } else {\n            this.xhr.onreadystatechange = empty;\n          }\n\n          if (fromError) {\n            try {\n              this.xhr.abort();\n            } catch (e) {}\n          }\n\n          if (global.document) {\n            delete Request.requests[this.index];\n          }\n\n          this.xhr = null;\n        };\n\n        /**\n         * Called upon load.\n         *\n         * @api private\n         */\n\n        Request.prototype.onLoad = function () {\n          var data;\n          try {\n            var contentType;\n            try {\n              contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n            } catch (e) {}\n            if (contentType === 'application/octet-stream') {\n              data = this.xhr.response;\n            } else {\n              if (!this.supportsBinary) {\n                data = this.xhr.responseText;\n              } else {\n                try {\n                  data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));\n                } catch (e) {\n                  var ui8Arr = new Uint8Array(this.xhr.response);\n                  var dataArray = [];\n                  for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {\n                    dataArray.push(ui8Arr[idx]);\n                  }\n\n                  data = String.fromCharCode.apply(null, dataArray);\n                }\n              }\n            }\n          } catch (e) {\n            this.onError(e);\n          }\n          if (null != data) {\n            this.onData(data);\n          }\n        };\n\n        /**\n         * Check if it has XDomainRequest.\n         *\n         * @api private\n         */\n\n        Request.prototype.hasXDR = function () {\n          return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n        };\n\n        /**\n         * Aborts the request.\n         *\n         * @api public\n         */\n\n        Request.prototype.abort = function () {\n          this.cleanup();\n        };\n\n        /**\n         * Aborts pending requests when unloading the window. This is needed to prevent\n         * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n         * emitted.\n         */\n\n        if (global.document) {\n          Request.requestsCount = 0;\n          Request.requests = {};\n          if (global.attachEvent) {\n            global.attachEvent('onunload', unloadHandler);\n          } else if (global.addEventListener) {\n            global.addEventListener('beforeunload', unloadHandler, false);\n          }\n        }\n\n        function unloadHandler() {\n          for (var i in Request.requests) {\n            if (Request.requests.hasOwnProperty(i)) {\n              Request.requests[i].abort();\n            }\n          }\n        }\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"./polling\": 23, \"component-emitter\": 26, \"component-inherit\": 13, \"debug\": 14, \"xmlhttprequest-ssl\": 25 }], 23: [function (_dereq_, module, exports) {\n      /**\n       * Module dependencies.\n       */\n\n      var Transport = _dereq_('../transport');\n      var parseqs = _dereq_('parseqs');\n      var parser = _dereq_('engine.io-parser');\n      var inherit = _dereq_('component-inherit');\n      var yeast = _dereq_('yeast');\n      var debug = _dereq_('debug')('engine.io-client:polling');\n\n      /**\n       * Module exports.\n       */\n\n      module.exports = Polling;\n\n      /**\n       * Is XHR2 supported?\n       */\n\n      var hasXHR2 = function () {\n        var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');\n        var xhr = new XMLHttpRequest({ xdomain: false });\n        return null != xhr.responseType;\n      }();\n\n      /**\n       * Polling interface.\n       *\n       * @param {Object} opts\n       * @api private\n       */\n\n      function Polling(opts) {\n        var forceBase64 = opts && opts.forceBase64;\n        if (!hasXHR2 || forceBase64) {\n          this.supportsBinary = false;\n        }\n        Transport.call(this, opts);\n      }\n\n      /**\n       * Inherits from Transport.\n       */\n\n      inherit(Polling, Transport);\n\n      /**\n       * Transport name.\n       */\n\n      Polling.prototype.name = 'polling';\n\n      /**\n       * Opens the socket (triggers polling). We write a PING message to determine\n       * when the transport is open.\n       *\n       * @api private\n       */\n\n      Polling.prototype.doOpen = function () {\n        this.poll();\n      };\n\n      /**\n       * Pauses polling.\n       *\n       * @param {Function} callback upon buffers are flushed and transport is paused\n       * @api private\n       */\n\n      Polling.prototype.pause = function (onPause) {\n        var pending = 0;\n        var self = this;\n\n        this.readyState = 'pausing';\n\n        function pause() {\n          debug('paused');\n          self.readyState = 'paused';\n          onPause();\n        }\n\n        if (this.polling || !this.writable) {\n          var total = 0;\n\n          if (this.polling) {\n            debug('we are currently polling - waiting to pause');\n            total++;\n            this.once('pollComplete', function () {\n              debug('pre-pause polling complete');\n              --total || pause();\n            });\n          }\n\n          if (!this.writable) {\n            debug('we are currently writing - waiting to pause');\n            total++;\n            this.once('drain', function () {\n              debug('pre-pause writing complete');\n              --total || pause();\n            });\n          }\n        } else {\n          pause();\n        }\n      };\n\n      /**\n       * Starts polling cycle.\n       *\n       * @api public\n       */\n\n      Polling.prototype.poll = function () {\n        debug('polling');\n        this.polling = true;\n        this.doPoll();\n        this.emit('poll');\n      };\n\n      /**\n       * Overloads onData to detect payloads.\n       *\n       * @api private\n       */\n\n      Polling.prototype.onData = function (data) {\n        var self = this;\n        debug('polling got data %s', data);\n        var callback = function callback(packet, index, total) {\n          // if its the first message we consider the transport open\n          if ('opening' == self.readyState) {\n            self.onOpen();\n          }\n\n          // if its a close packet, we close the ongoing requests\n          if ('close' == packet.type) {\n            self.onClose();\n            return false;\n          }\n\n          // otherwise bypass onData and handle the message\n          self.onPacket(packet);\n        };\n\n        // decode payload\n        parser.decodePayload(data, this.socket.binaryType, callback);\n\n        // if an event did not trigger closing\n        if ('closed' != this.readyState) {\n          // if we got data we're not polling\n          this.polling = false;\n          this.emit('pollComplete');\n\n          if ('open' == this.readyState) {\n            this.poll();\n          } else {\n            debug('ignoring poll - transport state \"%s\"', this.readyState);\n          }\n        }\n      };\n\n      /**\n       * For polling, send a close packet.\n       *\n       * @api private\n       */\n\n      Polling.prototype.doClose = function () {\n        var self = this;\n\n        function close() {\n          debug('writing close packet');\n          self.write([{ type: 'close' }]);\n        }\n\n        if ('open' == this.readyState) {\n          debug('transport open - closing');\n          close();\n        } else {\n          // in case we're trying to close while\n          // handshaking is in progress (GH-164)\n          debug('transport not open - deferring close');\n          this.once('open', close);\n        }\n      };\n\n      /**\n       * Writes a packets payload.\n       *\n       * @param {Array} data packets\n       * @param {Function} drain callback\n       * @api private\n       */\n\n      Polling.prototype.write = function (packets) {\n        var self = this;\n        this.writable = false;\n        var callbackfn = function callbackfn() {\n          self.writable = true;\n          self.emit('drain');\n        };\n\n        var self = this;\n        parser.encodePayload(packets, this.supportsBinary, function (data) {\n          self.doWrite(data, callbackfn);\n        });\n      };\n\n      /**\n       * Generates uri for connection.\n       *\n       * @api private\n       */\n\n      Polling.prototype.uri = function () {\n        var query = this.query || {};\n        var schema = this.secure ? 'https' : 'http';\n        var port = '';\n\n        // cache busting is forced\n        if (false !== this.timestampRequests) {\n          query[this.timestampParam] = yeast();\n        }\n\n        if (!this.supportsBinary && !query.sid) {\n          query.b64 = 1;\n        }\n\n        query = parseqs.encode(query);\n\n        // avoid port if default for schema\n        if (this.port && ('https' == schema && this.port != 443 || 'http' == schema && this.port != 80)) {\n          port = ':' + this.port;\n        }\n\n        // prepend ? to query\n        if (query.length) {\n          query = '?' + query;\n        }\n\n        var ipv6 = this.hostname.indexOf(':') !== -1;\n        return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n      };\n    }, { \"../transport\": 19, \"component-inherit\": 13, \"debug\": 14, \"engine.io-parser\": 27, \"parseqs\": 37, \"xmlhttprequest-ssl\": 25, \"yeast\": 45 }], 24: [function (_dereq_, module, exports) {\n      (function (global) {\n        /**\n         * Module dependencies.\n         */\n\n        var Transport = _dereq_('../transport');\n        var parser = _dereq_('engine.io-parser');\n        var parseqs = _dereq_('parseqs');\n        var inherit = _dereq_('component-inherit');\n        var yeast = _dereq_('yeast');\n        var debug = _dereq_('debug')('engine.io-client:websocket');\n        var BrowserWebSocket = global.WebSocket || global.MozWebSocket;\n\n        /**\n         * Get either the `WebSocket` or `MozWebSocket` globals\n         * in the browser or try to resolve WebSocket-compatible\n         * interface exposed by `ws` for Node-like environment.\n         */\n\n        var WebSocket = BrowserWebSocket;\n        if (!WebSocket && typeof window === 'undefined') {\n          try {\n            WebSocket = _dereq_('ws');\n          } catch (e) {}\n        }\n\n        /**\n         * Module exports.\n         */\n\n        module.exports = WS;\n\n        /**\n         * WebSocket transport constructor.\n         *\n         * @api {Object} connection options\n         * @api public\n         */\n\n        function WS(opts) {\n          var forceBase64 = opts && opts.forceBase64;\n          if (forceBase64) {\n            this.supportsBinary = false;\n          }\n          this.perMessageDeflate = opts.perMessageDeflate;\n          Transport.call(this, opts);\n        }\n\n        /**\n         * Inherits from Transport.\n         */\n\n        inherit(WS, Transport);\n\n        /**\n         * Transport name.\n         *\n         * @api public\n         */\n\n        WS.prototype.name = 'websocket';\n\n        /*\n         * WebSockets support binary\n         */\n\n        WS.prototype.supportsBinary = true;\n\n        /**\n         * Opens socket.\n         *\n         * @api private\n         */\n\n        WS.prototype.doOpen = function () {\n          if (!this.check()) {\n            // let probe timeout\n            return;\n          }\n\n          var self = this;\n          var uri = this.uri();\n          var protocols = void 0;\n          var opts = {\n            agent: this.agent,\n            perMessageDeflate: this.perMessageDeflate\n          };\n\n          // SSL options for Node.js client\n          opts.pfx = this.pfx;\n          opts.key = this.key;\n          opts.passphrase = this.passphrase;\n          opts.cert = this.cert;\n          opts.ca = this.ca;\n          opts.ciphers = this.ciphers;\n          opts.rejectUnauthorized = this.rejectUnauthorized;\n          if (this.extraHeaders) {\n            opts.headers = this.extraHeaders;\n          }\n\n          this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n\n          if (this.ws.binaryType === undefined) {\n            this.supportsBinary = false;\n          }\n\n          if (this.ws.supports && this.ws.supports.binary) {\n            this.supportsBinary = true;\n            this.ws.binaryType = 'buffer';\n          } else {\n            this.ws.binaryType = 'arraybuffer';\n          }\n\n          this.addEventListeners();\n        };\n\n        /**\n         * Adds event listeners to the socket\n         *\n         * @api private\n         */\n\n        WS.prototype.addEventListeners = function () {\n          var self = this;\n\n          this.ws.onopen = function () {\n            self.onOpen();\n          };\n          this.ws.onclose = function () {\n            self.onClose();\n          };\n          this.ws.onmessage = function (ev) {\n            self.onData(ev.data);\n          };\n          this.ws.onerror = function (e) {\n            self.onError('websocket error', e);\n          };\n        };\n\n        /**\n         * Override `onData` to use a timer on iOS.\n         * See: https://gist.github.com/mloughran/2052006\n         *\n         * @api private\n         */\n\n        if ('undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {\n          WS.prototype.onData = function (data) {\n            var self = this;\n            setTimeout(function () {\n              Transport.prototype.onData.call(self, data);\n            }, 0);\n          };\n        }\n\n        /**\n         * Writes data to socket.\n         *\n         * @param {Array} array of packets.\n         * @api private\n         */\n\n        WS.prototype.write = function (packets) {\n          var self = this;\n          this.writable = false;\n\n          // encodePacket efficient as it uses WS framing\n          // no need for encodePayload\n          var total = packets.length;\n          for (var i = 0, l = total; i < l; i++) {\n            (function (packet) {\n              parser.encodePacket(packet, self.supportsBinary, function (data) {\n                if (!BrowserWebSocket) {\n                  // always create a new object (GH-437)\n                  var opts = {};\n                  if (packet.options) {\n                    opts.compress = packet.options.compress;\n                  }\n\n                  if (self.perMessageDeflate) {\n                    var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;\n                    if (len < self.perMessageDeflate.threshold) {\n                      opts.compress = false;\n                    }\n                  }\n                }\n\n                //Sometimes the websocket has already been closed but the browser didn't\n                //have a chance of informing us about it yet, in that case send will\n                //throw an error\n                try {\n                  if (BrowserWebSocket) {\n                    // TypeError is thrown when passing the second argument on Safari\n                    self.ws.send(data);\n                  } else {\n                    self.ws.send(data, opts);\n                  }\n                } catch (e) {\n                  debug('websocket closed before onclose event');\n                }\n\n                --total || done();\n              });\n            })(packets[i]);\n          }\n\n          function done() {\n            self.emit('flush');\n\n            // fake drain\n            // defer to next tick to allow Socket to clear writeBuffer\n            setTimeout(function () {\n              self.writable = true;\n              self.emit('drain');\n            }, 0);\n          }\n        };\n\n        /**\n         * Called upon close\n         *\n         * @api private\n         */\n\n        WS.prototype.onClose = function () {\n          Transport.prototype.onClose.call(this);\n        };\n\n        /**\n         * Closes socket.\n         *\n         * @api private\n         */\n\n        WS.prototype.doClose = function () {\n          if (typeof this.ws !== 'undefined') {\n            this.ws.close();\n          }\n        };\n\n        /**\n         * Generates uri for connection.\n         *\n         * @api private\n         */\n\n        WS.prototype.uri = function () {\n          var query = this.query || {};\n          var schema = this.secure ? 'wss' : 'ws';\n          var port = '';\n\n          // avoid port if default for schema\n          if (this.port && ('wss' == schema && this.port != 443 || 'ws' == schema && this.port != 80)) {\n            port = ':' + this.port;\n          }\n\n          // append timestamp to URI\n          if (this.timestampRequests) {\n            query[this.timestampParam] = yeast();\n          }\n\n          // communicate binary support capabilities\n          if (!this.supportsBinary) {\n            query.b64 = 1;\n          }\n\n          query = parseqs.encode(query);\n\n          // prepend ? to query\n          if (query.length) {\n            query = '?' + query;\n          }\n\n          var ipv6 = this.hostname.indexOf(':') !== -1;\n          return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n        };\n\n        /**\n         * Feature detection for WebSocket.\n         *\n         * @return {Boolean} whether this transport is available.\n         * @api public\n         */\n\n        WS.prototype.check = function () {\n          return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n        };\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"../transport\": 19, \"component-inherit\": 13, \"debug\": 14, \"engine.io-parser\": 27, \"parseqs\": 37, \"ws\": undefined, \"yeast\": 45 }], 25: [function (_dereq_, module, exports) {\n      // browser shim for xmlhttprequest module\n      var hasCORS = _dereq_('has-cors');\n\n      module.exports = function (opts) {\n        var xdomain = opts.xdomain;\n\n        // scheme must be same when usign XDomainRequest\n        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n        var xscheme = opts.xscheme;\n\n        // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n        // https://github.com/Automattic/engine.io-client/pull/217\n        var enablesXDR = opts.enablesXDR;\n\n        // XMLHttpRequest can be disabled on IE\n        try {\n          if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n            return new XMLHttpRequest();\n          }\n        } catch (e) {}\n\n        // Use XDomainRequest for IE8 if enablesXDR is true\n        // because loading bar keeps flashing when using jsonp-polling\n        // https://github.com/yujiosaka/socke.io-ie8-loading-example\n        try {\n          if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {\n            return new XDomainRequest();\n          }\n        } catch (e) {}\n\n        if (!xdomain) {\n          try {\n            return new ActiveXObject('Microsoft.XMLHTTP');\n          } catch (e) {}\n        }\n      };\n    }, { \"has-cors\": 31 }], 26: [function (_dereq_, module, exports) {\n\n      /**\n       * Expose `Emitter`.\n       */\n\n      module.exports = Emitter;\n\n      /**\n       * Initialize a new `Emitter`.\n       *\n       * @api public\n       */\n\n      function Emitter(obj) {\n        if (obj) return mixin(obj);\n      };\n\n      /**\n       * Mixin the emitter properties.\n       *\n       * @param {Object} obj\n       * @return {Object}\n       * @api private\n       */\n\n      function mixin(obj) {\n        for (var key in Emitter.prototype) {\n          obj[key] = Emitter.prototype[key];\n        }\n        return obj;\n      }\n\n      /**\n       * Listen on the given `event` with `fn`.\n       *\n       * @param {String} event\n       * @param {Function} fn\n       * @return {Emitter}\n       * @api public\n       */\n\n      Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {\n        this._callbacks = this._callbacks || {};\n        (this._callbacks[event] = this._callbacks[event] || []).push(fn);\n        return this;\n      };\n\n      /**\n       * Adds an `event` listener that will be invoked a single\n       * time then automatically removed.\n       *\n       * @param {String} event\n       * @param {Function} fn\n       * @return {Emitter}\n       * @api public\n       */\n\n      Emitter.prototype.once = function (event, fn) {\n        var self = this;\n        this._callbacks = this._callbacks || {};\n\n        function on() {\n          self.off(event, on);\n          fn.apply(this, arguments);\n        }\n\n        on.fn = fn;\n        this.on(event, on);\n        return this;\n      };\n\n      /**\n       * Remove the given callback for `event` or all\n       * registered callbacks.\n       *\n       * @param {String} event\n       * @param {Function} fn\n       * @return {Emitter}\n       * @api public\n       */\n\n      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {\n        this._callbacks = this._callbacks || {};\n\n        // all\n        if (0 == arguments.length) {\n          this._callbacks = {};\n          return this;\n        }\n\n        // specific event\n        var callbacks = this._callbacks[event];\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (1 == arguments.length) {\n          delete this._callbacks[event];\n          return this;\n        }\n\n        // remove specific handler\n        var cb;\n        for (var i = 0; i < callbacks.length; i++) {\n          cb = callbacks[i];\n          if (cb === fn || cb.fn === fn) {\n            callbacks.splice(i, 1);\n            break;\n          }\n        }\n        return this;\n      };\n\n      /**\n       * Emit `event` with the given args.\n       *\n       * @param {String} event\n       * @param {Mixed} ...\n       * @return {Emitter}\n       */\n\n      Emitter.prototype.emit = function (event) {\n        this._callbacks = this._callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this._callbacks[event];\n\n        if (callbacks) {\n          callbacks = callbacks.slice(0);\n          for (var i = 0, len = callbacks.length; i < len; ++i) {\n            callbacks[i].apply(this, args);\n          }\n        }\n\n        return this;\n      };\n\n      /**\n       * Return array of callbacks for `event`.\n       *\n       * @param {String} event\n       * @return {Array}\n       * @api public\n       */\n\n      Emitter.prototype.listeners = function (event) {\n        this._callbacks = this._callbacks || {};\n        return this._callbacks[event] || [];\n      };\n\n      /**\n       * Check if this emitter has `event` handlers.\n       *\n       * @param {String} event\n       * @return {Boolean}\n       * @api public\n       */\n\n      Emitter.prototype.hasListeners = function (event) {\n        return !!this.listeners(event).length;\n      };\n    }, {}], 27: [function (_dereq_, module, exports) {\n      (function (global) {\n        /**\n         * Module dependencies.\n         */\n\n        var keys = _dereq_('./keys');\n        var hasBinary = _dereq_('has-binary');\n        var sliceBuffer = _dereq_('arraybuffer.slice');\n        var base64encoder = _dereq_('base64-arraybuffer');\n        var after = _dereq_('after');\n        var utf8 = _dereq_('utf8');\n\n        /**\n         * Check if we are running an android browser. That requires us to use\n         * ArrayBuffer with polling transports...\n         *\n         * http://ghinda.net/jpeg-blob-ajax-android/\n         */\n\n        var isAndroid = navigator.userAgent.match(/Android/i);\n\n        /**\n         * Check if we are running in PhantomJS.\n         * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n         * https://github.com/ariya/phantomjs/issues/11395\n         * @type boolean\n         */\n        var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);\n\n        /**\n         * When true, avoids using Blobs to encode payloads.\n         * @type boolean\n         */\n        var dontSendBlobs = isAndroid || isPhantomJS;\n\n        /**\n         * Current protocol version.\n         */\n\n        exports.protocol = 3;\n\n        /**\n         * Packet types.\n         */\n\n        var packets = exports.packets = {\n          open: 0 // non-ws\n          , close: 1 // non-ws\n          , ping: 2,\n          pong: 3,\n          message: 4,\n          upgrade: 5,\n          noop: 6\n        };\n\n        var packetslist = keys(packets);\n\n        /**\n         * Premade error packet.\n         */\n\n        var err = { type: 'error', data: 'parser error' };\n\n        /**\n         * Create a blob api even for blob builder when vendor prefixes exist\n         */\n\n        var Blob = _dereq_('blob');\n\n        /**\n         * Encodes a packet.\n         *\n         *     <packet type id> [ <data> ]\n         *\n         * Example:\n         *\n         *     5hello world\n         *     3\n         *     4\n         *\n         * Binary is encoded in an identical principle\n         *\n         * @api private\n         */\n\n        exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n          if ('function' == typeof supportsBinary) {\n            callback = supportsBinary;\n            supportsBinary = false;\n          }\n\n          if ('function' == typeof utf8encode) {\n            callback = utf8encode;\n            utf8encode = null;\n          }\n\n          var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;\n\n          if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n            return encodeArrayBuffer(packet, supportsBinary, callback);\n          } else if (Blob && data instanceof global.Blob) {\n            return encodeBlob(packet, supportsBinary, callback);\n          }\n\n          // might be an object with { base64: true, data: dataAsBase64String }\n          if (data && data.base64) {\n            return encodeBase64Object(packet, callback);\n          }\n\n          // Sending data as a utf-8 string\n          var encoded = packets[packet.type];\n\n          // data fragment is optional\n          if (undefined !== packet.data) {\n            encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n          }\n\n          return callback('' + encoded);\n        };\n\n        function encodeBase64Object(packet, callback) {\n          // packet data is an object { base64: true, data: dataAsBase64String }\n          var message = 'b' + exports.packets[packet.type] + packet.data.data;\n          return callback(message);\n        }\n\n        /**\n         * Encode packet helpers for binary types\n         */\n\n        function encodeArrayBuffer(packet, supportsBinary, callback) {\n          if (!supportsBinary) {\n            return exports.encodeBase64Packet(packet, callback);\n          }\n\n          var data = packet.data;\n          var contentArray = new Uint8Array(data);\n          var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n          resultBuffer[0] = packets[packet.type];\n          for (var i = 0; i < contentArray.length; i++) {\n            resultBuffer[i + 1] = contentArray[i];\n          }\n\n          return callback(resultBuffer.buffer);\n        }\n\n        function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n          if (!supportsBinary) {\n            return exports.encodeBase64Packet(packet, callback);\n          }\n\n          var fr = new FileReader();\n          fr.onload = function () {\n            packet.data = fr.result;\n            exports.encodePacket(packet, supportsBinary, true, callback);\n          };\n          return fr.readAsArrayBuffer(packet.data);\n        }\n\n        function encodeBlob(packet, supportsBinary, callback) {\n          if (!supportsBinary) {\n            return exports.encodeBase64Packet(packet, callback);\n          }\n\n          if (dontSendBlobs) {\n            return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n          }\n\n          var length = new Uint8Array(1);\n          length[0] = packets[packet.type];\n          var blob = new Blob([length.buffer, packet.data]);\n\n          return callback(blob);\n        }\n\n        /**\n         * Encodes a packet with binary data in a base64 string\n         *\n         * @param {Object} packet, has `type` and `data`\n         * @return {String} base64 encoded message\n         */\n\n        exports.encodeBase64Packet = function (packet, callback) {\n          var message = 'b' + exports.packets[packet.type];\n          if (Blob && packet.data instanceof global.Blob) {\n            var fr = new FileReader();\n            fr.onload = function () {\n              var b64 = fr.result.split(',')[1];\n              callback(message + b64);\n            };\n            return fr.readAsDataURL(packet.data);\n          }\n\n          var b64data;\n          try {\n            b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n          } catch (e) {\n            // iPhone Safari doesn't let you apply with typed arrays\n            var typed = new Uint8Array(packet.data);\n            var basic = new Array(typed.length);\n            for (var i = 0; i < typed.length; i++) {\n              basic[i] = typed[i];\n            }\n            b64data = String.fromCharCode.apply(null, basic);\n          }\n          message += global.btoa(b64data);\n          return callback(message);\n        };\n\n        /**\n         * Decodes a packet. Changes format to Blob if requested.\n         *\n         * @return {Object} with `type` and `data` (if any)\n         * @api private\n         */\n\n        exports.decodePacket = function (data, binaryType, utf8decode) {\n          // String data\n          if (typeof data == 'string' || data === undefined) {\n            if (data.charAt(0) == 'b') {\n              return exports.decodeBase64Packet(data.substr(1), binaryType);\n            }\n\n            if (utf8decode) {\n              try {\n                data = utf8.decode(data);\n              } catch (e) {\n                return err;\n              }\n            }\n            var type = data.charAt(0);\n\n            if (Number(type) != type || !packetslist[type]) {\n              return err;\n            }\n\n            if (data.length > 1) {\n              return { type: packetslist[type], data: data.substring(1) };\n            } else {\n              return { type: packetslist[type] };\n            }\n          }\n\n          var asArray = new Uint8Array(data);\n          var type = asArray[0];\n          var rest = sliceBuffer(data, 1);\n          if (Blob && binaryType === 'blob') {\n            rest = new Blob([rest]);\n          }\n          return { type: packetslist[type], data: rest };\n        };\n\n        /**\n         * Decodes a packet encoded in a base64 string\n         *\n         * @param {String} base64 encoded message\n         * @return {Object} with `type` and `data` (if any)\n         */\n\n        exports.decodeBase64Packet = function (msg, binaryType) {\n          var type = packetslist[msg.charAt(0)];\n          if (!global.ArrayBuffer) {\n            return { type: type, data: { base64: true, data: msg.substr(1) } };\n          }\n\n          var data = base64encoder.decode(msg.substr(1));\n\n          if (binaryType === 'blob' && Blob) {\n            data = new Blob([data]);\n          }\n\n          return { type: type, data: data };\n        };\n\n        /**\n         * Encodes multiple messages (payload).\n         *\n         *     <length>:data\n         *\n         * Example:\n         *\n         *     11:hello world2:hi\n         *\n         * If any contents are binary, they will be encoded as base64 strings. Base64\n         * encoded strings are marked with a b before the length specifier\n         *\n         * @param {Array} packets\n         * @api private\n         */\n\n        exports.encodePayload = function (packets, supportsBinary, callback) {\n          if (typeof supportsBinary == 'function') {\n            callback = supportsBinary;\n            supportsBinary = null;\n          }\n\n          var isBinary = hasBinary(packets);\n\n          if (supportsBinary && isBinary) {\n            if (Blob && !dontSendBlobs) {\n              return exports.encodePayloadAsBlob(packets, callback);\n            }\n\n            return exports.encodePayloadAsArrayBuffer(packets, callback);\n          }\n\n          if (!packets.length) {\n            return callback('0:');\n          }\n\n          function setLengthHeader(message) {\n            return message.length + ':' + message;\n          }\n\n          function encodeOne(packet, doneCallback) {\n            exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function (message) {\n              doneCallback(null, setLengthHeader(message));\n            });\n          }\n\n          map(packets, encodeOne, function (err, results) {\n            return callback(results.join(''));\n          });\n        };\n\n        /**\n         * Async array map using after\n         */\n\n        function map(ary, each, done) {\n          var result = new Array(ary.length);\n          var next = after(ary.length, done);\n\n          var eachWithIndex = function eachWithIndex(i, el, cb) {\n            each(el, function (error, msg) {\n              result[i] = msg;\n              cb(error, result);\n            });\n          };\n\n          for (var i = 0; i < ary.length; i++) {\n            eachWithIndex(i, ary[i], next);\n          }\n        }\n\n        /*\n         * Decodes data when a payload is maybe expected. Possible binary contents are\n         * decoded from their base64 representation\n         *\n         * @param {String} data, callback method\n         * @api public\n         */\n\n        exports.decodePayload = function (data, binaryType, callback) {\n          if (typeof data != 'string') {\n            return exports.decodePayloadAsBinary(data, binaryType, callback);\n          }\n\n          if (typeof binaryType === 'function') {\n            callback = binaryType;\n            binaryType = null;\n          }\n\n          var packet;\n          if (data == '') {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n          }\n\n          var length = '',\n              n,\n              msg;\n\n          for (var i = 0, l = data.length; i < l; i++) {\n            var chr = data.charAt(i);\n\n            if (':' != chr) {\n              length += chr;\n            } else {\n              if ('' == length || length != (n = Number(length))) {\n                // parser error - ignoring payload\n                return callback(err, 0, 1);\n              }\n\n              msg = data.substr(i + 1, n);\n\n              if (length != msg.length) {\n                // parser error - ignoring payload\n                return callback(err, 0, 1);\n              }\n\n              if (msg.length) {\n                packet = exports.decodePacket(msg, binaryType, true);\n\n                if (err.type == packet.type && err.data == packet.data) {\n                  // parser error in individual packet - ignoring payload\n                  return callback(err, 0, 1);\n                }\n\n                var ret = callback(packet, i + n, l);\n                if (false === ret) return;\n              }\n\n              // advance cursor\n              i += n;\n              length = '';\n            }\n          }\n\n          if (length != '') {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n          }\n        };\n\n        /**\n         * Encodes multiple messages (payload) as binary.\n         *\n         * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n         * 255><data>\n         *\n         * Example:\n         * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n         *\n         * @param {Array} packets\n         * @return {ArrayBuffer} encoded payload\n         * @api private\n         */\n\n        exports.encodePayloadAsArrayBuffer = function (packets, callback) {\n          if (!packets.length) {\n            return callback(new ArrayBuffer(0));\n          }\n\n          function encodeOne(packet, doneCallback) {\n            exports.encodePacket(packet, true, true, function (data) {\n              return doneCallback(null, data);\n            });\n          }\n\n          map(packets, encodeOne, function (err, encodedPackets) {\n            var totalLength = encodedPackets.reduce(function (acc, p) {\n              var len;\n              if (typeof p === 'string') {\n                len = p.length;\n              } else {\n                len = p.byteLength;\n              }\n              return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n            }, 0);\n\n            var resultArray = new Uint8Array(totalLength);\n\n            var bufferIndex = 0;\n            encodedPackets.forEach(function (p) {\n              var isString = typeof p === 'string';\n              var ab = p;\n              if (isString) {\n                var view = new Uint8Array(p.length);\n                for (var i = 0; i < p.length; i++) {\n                  view[i] = p.charCodeAt(i);\n                }\n                ab = view.buffer;\n              }\n\n              if (isString) {\n                // not true binary\n                resultArray[bufferIndex++] = 0;\n              } else {\n                // true binary\n                resultArray[bufferIndex++] = 1;\n              }\n\n              var lenStr = ab.byteLength.toString();\n              for (var i = 0; i < lenStr.length; i++) {\n                resultArray[bufferIndex++] = parseInt(lenStr[i]);\n              }\n              resultArray[bufferIndex++] = 255;\n\n              var view = new Uint8Array(ab);\n              for (var i = 0; i < view.length; i++) {\n                resultArray[bufferIndex++] = view[i];\n              }\n            });\n\n            return callback(resultArray.buffer);\n          });\n        };\n\n        /**\n         * Encode as Blob\n         */\n\n        exports.encodePayloadAsBlob = function (packets, callback) {\n          function encodeOne(packet, doneCallback) {\n            exports.encodePacket(packet, true, true, function (encoded) {\n              var binaryIdentifier = new Uint8Array(1);\n              binaryIdentifier[0] = 1;\n              if (typeof encoded === 'string') {\n                var view = new Uint8Array(encoded.length);\n                for (var i = 0; i < encoded.length; i++) {\n                  view[i] = encoded.charCodeAt(i);\n                }\n                encoded = view.buffer;\n                binaryIdentifier[0] = 0;\n              }\n\n              var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;\n\n              var lenStr = len.toString();\n              var lengthAry = new Uint8Array(lenStr.length + 1);\n              for (var i = 0; i < lenStr.length; i++) {\n                lengthAry[i] = parseInt(lenStr[i]);\n              }\n              lengthAry[lenStr.length] = 255;\n\n              if (Blob) {\n                var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n                doneCallback(null, blob);\n              }\n            });\n          }\n\n          map(packets, encodeOne, function (err, results) {\n            return callback(new Blob(results));\n          });\n        };\n\n        /*\n         * Decodes data when a payload is maybe expected. Strings are decoded by\n         * interpreting each byte as a key code for entries marked to start with 0. See\n         * description of encodePayloadAsBinary\n         *\n         * @param {ArrayBuffer} data, callback method\n         * @api public\n         */\n\n        exports.decodePayloadAsBinary = function (data, binaryType, callback) {\n          if (typeof binaryType === 'function') {\n            callback = binaryType;\n            binaryType = null;\n          }\n\n          var bufferTail = data;\n          var buffers = [];\n\n          var numberTooLong = false;\n          while (bufferTail.byteLength > 0) {\n            var tailArray = new Uint8Array(bufferTail);\n            var isString = tailArray[0] === 0;\n            var msgLength = '';\n\n            for (var i = 1;; i++) {\n              if (tailArray[i] == 255) break;\n\n              if (msgLength.length > 310) {\n                numberTooLong = true;\n                break;\n              }\n\n              msgLength += tailArray[i];\n            }\n\n            if (numberTooLong) return callback(err, 0, 1);\n\n            bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n            msgLength = parseInt(msgLength);\n\n            var msg = sliceBuffer(bufferTail, 0, msgLength);\n            if (isString) {\n              try {\n                msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n              } catch (e) {\n                // iPhone Safari doesn't let you apply to typed arrays\n                var typed = new Uint8Array(msg);\n                msg = '';\n                for (var i = 0; i < typed.length; i++) {\n                  msg += String.fromCharCode(typed[i]);\n                }\n              }\n            }\n\n            buffers.push(msg);\n            bufferTail = sliceBuffer(bufferTail, msgLength);\n          }\n\n          var total = buffers.length;\n          buffers.forEach(function (buffer, i) {\n            callback(exports.decodePacket(buffer, binaryType, true), i, total);\n          });\n        };\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"./keys\": 28, \"after\": 6, \"arraybuffer.slice\": 7, \"base64-arraybuffer\": 9, \"blob\": 10, \"has-binary\": 29, \"utf8\": 44 }], 28: [function (_dereq_, module, exports) {\n\n      /**\n       * Gets the keys for an object.\n       *\n       * @return {Array} keys\n       * @api private\n       */\n\n      module.exports = Object.keys || function keys(obj) {\n        var arr = [];\n        var has = Object.prototype.hasOwnProperty;\n\n        for (var i in obj) {\n          if (has.call(obj, i)) {\n            arr.push(i);\n          }\n        }\n        return arr;\n      };\n    }, {}], 29: [function (_dereq_, module, exports) {\n      (function (global) {\n\n        /*\n         * Module requirements.\n         */\n\n        var isArray = _dereq_('isarray');\n\n        /**\n         * Module exports.\n         */\n\n        module.exports = hasBinary;\n\n        /**\n         * Checks for binary data.\n         *\n         * Right now only Buffer and ArrayBuffer are supported..\n         *\n         * @param {Object} anything\n         * @api public\n         */\n\n        function hasBinary(data) {\n\n          function _hasBinary(obj) {\n            if (!obj) return false;\n\n            if (global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {\n              return true;\n            }\n\n            if (isArray(obj)) {\n              for (var i = 0; i < obj.length; i++) {\n                if (_hasBinary(obj[i])) {\n                  return true;\n                }\n              }\n            } else if (obj && 'object' == (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj))) {\n              if (obj.toJSON) {\n                obj = obj.toJSON();\n              }\n\n              for (var key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          }\n\n          return _hasBinary(data);\n        }\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"isarray\": 33 }], 30: [function (_dereq_, module, exports) {\n      (function (global) {\n\n        /*\n         * Module requirements.\n         */\n\n        var isArray = _dereq_('isarray');\n\n        /**\n         * Module exports.\n         */\n\n        module.exports = hasBinary;\n\n        /**\n         * Checks for binary data.\n         *\n         * Right now only Buffer and ArrayBuffer are supported..\n         *\n         * @param {Object} anything\n         * @api public\n         */\n\n        function hasBinary(data) {\n\n          function _hasBinary(obj) {\n            if (!obj) return false;\n\n            if (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {\n              return true;\n            }\n\n            if (isArray(obj)) {\n              for (var i = 0; i < obj.length; i++) {\n                if (_hasBinary(obj[i])) {\n                  return true;\n                }\n              }\n            } else if (obj && 'object' == (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj))) {\n              // see: https://github.com/Automattic/has-binary/pull/4\n              if (obj.toJSON && 'function' == typeof obj.toJSON) {\n                obj = obj.toJSON();\n              }\n\n              for (var key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          }\n\n          return _hasBinary(data);\n        }\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"isarray\": 33 }], 31: [function (_dereq_, module, exports) {\n\n      /**\n       * Module exports.\n       *\n       * Logic borrowed from Modernizr:\n       *\n       *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n       */\n\n      try {\n        module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();\n      } catch (err) {\n        // if XMLHttp support is disabled in IE then it will throw\n        // when trying to create\n        module.exports = false;\n      }\n    }, {}], 32: [function (_dereq_, module, exports) {\n\n      var indexOf = [].indexOf;\n\n      module.exports = function (arr, obj) {\n        if (indexOf) return arr.indexOf(obj);\n        for (var i = 0; i < arr.length; ++i) {\n          if (arr[i] === obj) return i;\n        }\n        return -1;\n      };\n    }, {}], 33: [function (_dereq_, module, exports) {\n      module.exports = Array.isArray || function (arr) {\n        return Object.prototype.toString.call(arr) == '[object Array]';\n      };\n    }, {}], 34: [function (_dereq_, module, exports) {\n      (function (global) {\n        /*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n        ;(function () {\n          // Detect the `define` function exposed by asynchronous module loaders. The\n          // strict `define` check is necessary for compatibility with `r.js`.\n          var isLoader = typeof define === \"function\" && define.amd;\n\n          // A set of types used to distinguish objects from primitives.\n          var objectTypes = {\n            \"function\": true,\n            \"object\": true\n          };\n\n          // Detect the `exports` object exposed by CommonJS implementations.\n          var freeExports = objectTypes[typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)] && exports && !exports.nodeType && exports;\n\n          // Use the `global` object exposed by Node (including Browserify via\n          // `insert-module-globals`), Narwhal, and Ringo as the default context,\n          // and the `window` object in browsers. Rhino exports a `global` function\n          // instead.\n          var root = objectTypes[typeof window === \"undefined\" ? \"undefined\" : _typeof(window)] && window || this,\n              freeGlobal = freeExports && objectTypes[typeof module === \"undefined\" ? \"undefined\" : _typeof(module)] && module && !module.nodeType && (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == \"object\" && global;\n\n          if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n            root = freeGlobal;\n          }\n\n          // Public: Initializes JSON 3 using the given `context` object, attaching the\n          // `stringify` and `parse` functions to the specified `exports` object.\n          function runInContext(context, exports) {\n            context || (context = root[\"Object\"]());\n            exports || (exports = root[\"Object\"]());\n\n            // Native constructor aliases.\n            var Number = context[\"Number\"] || root[\"Number\"],\n                String = context[\"String\"] || root[\"String\"],\n                Object = context[\"Object\"] || root[\"Object\"],\n                Date = context[\"Date\"] || root[\"Date\"],\n                SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n                TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n                Math = context[\"Math\"] || root[\"Math\"],\n                nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n            // Delegate to the native `stringify` and `parse` implementations.\n            if ((typeof nativeJSON === \"undefined\" ? \"undefined\" : _typeof(nativeJSON)) == \"object\" && nativeJSON) {\n              exports.stringify = nativeJSON.stringify;\n              exports.parse = nativeJSON.parse;\n            }\n\n            // Convenience aliases.\n            var objectProto = Object.prototype,\n                getClass = objectProto.toString,\n                _isProperty,\n                _forEach,\n                undef;\n\n            // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n            var isExtended = new Date(-3509827334573292);\n            try {\n              // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n              // results for certain dates in Opera >= 10.53.\n              isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n              // Safari < 2.0.2 stores the internal millisecond time value correctly,\n              // but clips the values returned by the date methods to the range of\n              // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n              isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n            } catch (exception) {}\n\n            // Internal: Determines whether the native `JSON.stringify` and `parse`\n            // implementations are spec-compliant. Based on work by Ken Snyder.\n            function has(name) {\n              if (has[name] !== undef) {\n                // Return cached feature test result.\n                return has[name];\n              }\n              var isSupported;\n              if (name == \"bug-string-char-index\") {\n                // IE <= 7 doesn't support accessing string characters using square\n                // bracket notation. IE 8 only supports this for primitives.\n                isSupported = \"a\"[0] != \"a\";\n              } else if (name == \"json\") {\n                // Indicates whether both `JSON.stringify` and `JSON.parse` are\n                // supported.\n                isSupported = has(\"json-stringify\") && has(\"json-parse\");\n              } else {\n                var value,\n                    serialized = \"{\\\"a\\\":[1,true,false,null,\\\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\\\"]}\";\n                // Test `JSON.stringify`.\n                if (name == \"json-stringify\") {\n                  var stringify = exports.stringify,\n                      stringifySupported = typeof stringify == \"function\" && isExtended;\n                  if (stringifySupported) {\n                    // A test function object with a custom `toJSON` method.\n                    (value = function value() {\n                      return 1;\n                    }).toJSON = value;\n                    try {\n                      stringifySupported =\n                      // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                      // primitives as object literals.\n                      stringify(0) === \"0\" &&\n                      // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                      // literals.\n                      stringify(new Number()) === \"0\" && stringify(new String()) == '\"\"' &&\n                      // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                      // does not define a canonical JSON representation (this applies to\n                      // objects with `toJSON` properties as well, *unless* they are nested\n                      // within an object or array).\n                      stringify(getClass) === undef &&\n                      // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                      // FF 3.1b3 pass this test.\n                      stringify(undef) === undef &&\n                      // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                      // respectively, if the value is omitted entirely.\n                      stringify() === undef &&\n                      // FF 3.1b1, 2 throw an error if the given value is not a number,\n                      // string, array, object, Boolean, or `null` literal. This applies to\n                      // objects with custom `toJSON` methods as well, unless they are nested\n                      // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                      // methods entirely.\n                      stringify(value) === \"1\" && stringify([value]) == \"[1]\" &&\n                      // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                      // `\"[null]\"`.\n                      stringify([undef]) == \"[null]\" &&\n                      // YUI 3.0.0b1 fails to serialize `null` literals.\n                      stringify(null) == \"null\" &&\n                      // FF 3.1b1, 2 halts serialization if an array contains a function:\n                      // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                      // elides non-JSON values from objects and arrays, unless they\n                      // define custom `toJSON` methods.\n                      stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                      // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                      // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                      stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                      // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                      stringify(null, value) === \"1\" && stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                      // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                      // serialize extended years.\n                      stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                      // The milliseconds are optional in ES 5, but required in 5.1.\n                      stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                      // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                      // four-digit years instead of six-digit years. Credits: @Yaffle.\n                      stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                      // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                      // values less than 1000. Credits: @Yaffle.\n                      stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n                    } catch (exception) {\n                      stringifySupported = false;\n                    }\n                  }\n                  isSupported = stringifySupported;\n                }\n                // Test `JSON.parse`.\n                if (name == \"json-parse\") {\n                  var parse = exports.parse;\n                  if (typeof parse == \"function\") {\n                    try {\n                      // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n                      // Conforming implementations should also coerce the initial argument to\n                      // a string prior to parsing.\n                      if (parse(\"0\") === 0 && !parse(false)) {\n                        // Simple parsing test.\n                        value = parse(serialized);\n                        var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                        if (parseSupported) {\n                          try {\n                            // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                            parseSupported = !parse('\"\\t\"');\n                          } catch (exception) {}\n                          if (parseSupported) {\n                            try {\n                              // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                              // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                              // certain octal literals.\n                              parseSupported = parse(\"01\") !== 1;\n                            } catch (exception) {}\n                          }\n                          if (parseSupported) {\n                            try {\n                              // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                              // points. These environments, along with FF 3.1b1 and 2,\n                              // also allow trailing commas in JSON objects and arrays.\n                              parseSupported = parse(\"1.\") !== 1;\n                            } catch (exception) {}\n                          }\n                        }\n                      }\n                    } catch (exception) {\n                      parseSupported = false;\n                    }\n                  }\n                  isSupported = parseSupported;\n                }\n              }\n              return has[name] = !!isSupported;\n            }\n\n            if (!has(\"json\")) {\n              // Common `[[Class]]` name aliases.\n              var functionClass = \"[object Function]\",\n                  dateClass = \"[object Date]\",\n                  numberClass = \"[object Number]\",\n                  stringClass = \"[object String]\",\n                  arrayClass = \"[object Array]\",\n                  booleanClass = \"[object Boolean]\";\n\n              // Detect incomplete support for accessing string characters by index.\n              var charIndexBuggy = has(\"bug-string-char-index\");\n\n              // Define additional utility methods if the `Date` methods are buggy.\n              if (!isExtended) {\n                var floor = Math.floor;\n                // A mapping between the months of the year and the number of days between\n                // January 1st and the first of the respective month.\n                var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n                // Internal: Calculates the number of days between the Unix epoch and the\n                // first day of the given month.\n                var getDay = function getDay(year, month) {\n                  return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n                };\n              }\n\n              // Internal: Determines if a property is a direct property of the given\n              // object. Delegates to the native `Object#hasOwnProperty` method.\n              if (!(_isProperty = objectProto.hasOwnProperty)) {\n                _isProperty = function isProperty(property) {\n                  var members = {},\n                      constructor;\n                  if ((members.__proto__ = null, members.__proto__ = {\n                    // The *proto* property cannot be set multiple times in recent\n                    // versions of Firefox and SeaMonkey.\n                    \"toString\": 1\n                  }, members).toString != getClass) {\n                    // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n                    // supports the mutable *proto* property.\n                    _isProperty = function isProperty(property) {\n                      // Capture and break the object's prototype chain (see section 8.6.2\n                      // of the ES 5.1 spec). The parenthesized expression prevents an\n                      // unsafe transformation by the Closure Compiler.\n                      var original = this.__proto__,\n                          result = property in (this.__proto__ = null, this);\n                      // Restore the original prototype chain.\n                      this.__proto__ = original;\n                      return result;\n                    };\n                  } else {\n                    // Capture a reference to the top-level `Object` constructor.\n                    constructor = members.constructor;\n                    // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n                    // other environments.\n                    _isProperty = function isProperty(property) {\n                      var parent = (this.constructor || constructor).prototype;\n                      return property in this && !(property in parent && this[property] === parent[property]);\n                    };\n                  }\n                  members = null;\n                  return _isProperty.call(this, property);\n                };\n              }\n\n              // Internal: Normalizes the `for...in` iteration algorithm across\n              // environments. Each enumerated key is yielded to a `callback` function.\n              _forEach = function forEach(object, callback) {\n                var size = 0,\n                    Properties,\n                    members,\n                    property;\n\n                // Tests for bugs in the current environment's `for...in` algorithm. The\n                // `valueOf` property inherits the non-enumerable flag from\n                // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n                (Properties = function Properties() {\n                  this.valueOf = 0;\n                }).prototype.valueOf = 0;\n\n                // Iterate over a new instance of the `Properties` class.\n                members = new Properties();\n                for (property in members) {\n                  // Ignore all properties inherited from `Object.prototype`.\n                  if (_isProperty.call(members, property)) {\n                    size++;\n                  }\n                }\n                Properties = members = null;\n\n                // Normalize the iteration algorithm.\n                if (!size) {\n                  // A list of non-enumerable properties inherited from `Object.prototype`.\n                  members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n                  // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n                  // properties.\n                  _forEach = function forEach(object, callback) {\n                    var isFunction = getClass.call(object) == functionClass,\n                        property,\n                        length;\n                    var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;\n                    for (property in object) {\n                      // Gecko <= 1.0 enumerates the `prototype` property of functions under\n                      // certain conditions; IE does not.\n                      if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                        callback(property);\n                      }\n                    }\n                    // Manually invoke the callback for each non-enumerable property.\n                    for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}\n                  };\n                } else if (size == 2) {\n                  // Safari <= 2.0.4 enumerates shadowed properties twice.\n                  _forEach = function forEach(object, callback) {\n                    // Create a set of iterated properties.\n                    var members = {},\n                        isFunction = getClass.call(object) == functionClass,\n                        property;\n                    for (property in object) {\n                      // Store each property name to prevent double enumeration. The\n                      // `prototype` property of functions is not enumerated due to cross-\n                      // environment inconsistencies.\n                      if (!(isFunction && property == \"prototype\") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {\n                        callback(property);\n                      }\n                    }\n                  };\n                } else {\n                  // No bugs detected; use the standard `for...in` algorithm.\n                  _forEach = function forEach(object, callback) {\n                    var isFunction = getClass.call(object) == functionClass,\n                        property,\n                        isConstructor;\n                    for (property in object) {\n                      if (!(isFunction && property == \"prototype\") && _isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                        callback(property);\n                      }\n                    }\n                    // Manually invoke the callback for the `constructor` property due to\n                    // cross-environment inconsistencies.\n                    if (isConstructor || _isProperty.call(object, property = \"constructor\")) {\n                      callback(property);\n                    }\n                  };\n                }\n                return _forEach(object, callback);\n              };\n\n              // Public: Serializes a JavaScript `value` as a JSON string. The optional\n              // `filter` argument may specify either a function that alters how object and\n              // array members are serialized, or an array of strings and numbers that\n              // indicates which properties should be serialized. The optional `width`\n              // argument may be either a string or number that specifies the indentation\n              // level of the output.\n              if (!has(\"json-stringify\")) {\n                // Internal: A map of control characters and their escaped equivalents.\n                var Escapes = {\n                  92: \"\\\\\\\\\",\n                  34: '\\\\\"',\n                  8: \"\\\\b\",\n                  12: \"\\\\f\",\n                  10: \"\\\\n\",\n                  13: \"\\\\r\",\n                  9: \"\\\\t\"\n                };\n\n                // Internal: Converts `value` into a zero-padded string such that its\n                // length is at least equal to `width`. The `width` must be <= 6.\n                var leadingZeroes = \"000000\";\n                var toPaddedString = function toPaddedString(width, value) {\n                  // The `|| 0` expression is necessary to work around a bug in\n                  // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n                  return (leadingZeroes + (value || 0)).slice(-width);\n                };\n\n                // Internal: Double-quotes a string `value`, replacing all ASCII control\n                // characters (characters with code unit values between 0 and 31) with\n                // their escaped equivalents. This is an implementation of the\n                // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n                var unicodePrefix = \"\\\\u00\";\n                var quote = function quote(value) {\n                  var result = '\"',\n                      index = 0,\n                      length = value.length,\n                      useCharIndex = !charIndexBuggy || length > 10;\n                  var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n                  for (; index < length; index++) {\n                    var charCode = value.charCodeAt(index);\n                    // If the character is a control character, append its Unicode or\n                    // shorthand escape sequence; otherwise, append the character as-is.\n                    switch (charCode) {\n                      case 8:case 9:case 10:case 12:case 13:case 34:case 92:\n                        result += Escapes[charCode];\n                        break;\n                      default:\n                        if (charCode < 32) {\n                          result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                          break;\n                        }\n                        result += useCharIndex ? symbols[index] : value.charAt(index);\n                    }\n                  }\n                  return result + '\"';\n                };\n\n                // Internal: Recursively serializes an object. Implements the\n                // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n                var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {\n                  var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n                  try {\n                    // Necessary for host object support.\n                    value = object[property];\n                  } catch (exception) {}\n                  if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) == \"object\" && value) {\n                    className = getClass.call(value);\n                    if (className == dateClass && !_isProperty.call(value, \"toJSON\")) {\n                      if (value > -1 / 0 && value < 1 / 0) {\n                        // Dates are serialized according to the `Date#toJSON` method\n                        // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                        // for the ISO 8601 date time string format.\n                        if (getDay) {\n                          // Manually compute the year, month, date, hours, minutes,\n                          // seconds, and milliseconds if the `getUTC*` methods are\n                          // buggy. Adapted from @Yaffle's `date-shim` project.\n                          date = floor(value / 864e5);\n                          for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}\n                          for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}\n                          date = 1 + date - getDay(year, month);\n                          // The `time` value specifies the time within the day (see ES\n                          // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                          // to compute `A modulo B`, as the `%` operator does not\n                          // correspond to the `modulo` operation for negative numbers.\n                          time = (value % 864e5 + 864e5) % 864e5;\n                          // The hours, minutes, seconds, and milliseconds are obtained by\n                          // decomposing the time within the day. See section 15.9.1.10.\n                          hours = floor(time / 36e5) % 24;\n                          minutes = floor(time / 6e4) % 60;\n                          seconds = floor(time / 1e3) % 60;\n                          milliseconds = time % 1e3;\n                        } else {\n                          year = value.getUTCFullYear();\n                          month = value.getUTCMonth();\n                          date = value.getUTCDate();\n                          hours = value.getUTCHours();\n                          minutes = value.getUTCMinutes();\n                          seconds = value.getUTCSeconds();\n                          milliseconds = value.getUTCMilliseconds();\n                        }\n                        // Serialize extended years correctly.\n                        value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                        // Months, dates, hours, minutes, and seconds should have two\n                        // digits; milliseconds should have three.\n                        \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                        // Milliseconds are optional in ES 5.0, but required in 5.1.\n                        \".\" + toPaddedString(3, milliseconds) + \"Z\";\n                      } else {\n                        value = null;\n                      }\n                    } else if (typeof value.toJSON == \"function\" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, \"toJSON\"))) {\n                      // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n                      // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n                      // ignores all `toJSON` methods on these objects unless they are\n                      // defined directly on an instance.\n                      value = value.toJSON(property);\n                    }\n                  }\n                  if (callback) {\n                    // If a replacement function was provided, call it to obtain the value\n                    // for serialization.\n                    value = callback.call(object, property, value);\n                  }\n                  if (value === null) {\n                    return \"null\";\n                  }\n                  className = getClass.call(value);\n                  if (className == booleanClass) {\n                    // Booleans are represented literally.\n                    return \"\" + value;\n                  } else if (className == numberClass) {\n                    // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n                    // `\"null\"`.\n                    return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n                  } else if (className == stringClass) {\n                    // Strings are double-quoted and escaped.\n                    return quote(\"\" + value);\n                  }\n                  // Recursively serialize objects and arrays.\n                  if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) == \"object\") {\n                    // Check for cyclic structures. This is a linear search; performance\n                    // is inversely proportional to the number of unique nested objects.\n                    for (length = stack.length; length--;) {\n                      if (stack[length] === value) {\n                        // Cyclic structures cannot be serialized by `JSON.stringify`.\n                        throw TypeError();\n                      }\n                    }\n                    // Add the object to the stack of traversed objects.\n                    stack.push(value);\n                    results = [];\n                    // Save the current indentation level and indent one additional level.\n                    prefix = indentation;\n                    indentation += whitespace;\n                    if (className == arrayClass) {\n                      // Recursively serialize array elements.\n                      for (index = 0, length = value.length; index < length; index++) {\n                        element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                        results.push(element === undef ? \"null\" : element);\n                      }\n                      result = results.length ? whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : \"[\" + results.join(\",\") + \"]\" : \"[]\";\n                    } else {\n                      // Recursively serialize object members. Members are selected from\n                      // either a user-specified list of property names, or the object\n                      // itself.\n                      _forEach(properties || value, function (property) {\n                        var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                        if (element !== undef) {\n                          // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                          // is not the empty string, let `member` {quote(property) + \":\"}\n                          // be the concatenation of `member` and the `space` character.\"\n                          // The \"`space` character\" refers to the literal space\n                          // character, not the `space` {width} argument provided to\n                          // `JSON.stringify`.\n                          results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                        }\n                      });\n                      result = results.length ? whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : \"{\" + results.join(\",\") + \"}\" : \"{}\";\n                    }\n                    // Remove the object from the traversed object stack.\n                    stack.pop();\n                    return result;\n                  }\n                };\n\n                // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n                exports.stringify = function (source, filter, width) {\n                  var whitespace, callback, properties, className;\n                  if (objectTypes[typeof filter === \"undefined\" ? \"undefined\" : _typeof(filter)] && filter) {\n                    if ((className = getClass.call(filter)) == functionClass) {\n                      callback = filter;\n                    } else if (className == arrayClass) {\n                      // Convert the property names array into a makeshift set.\n                      properties = {};\n                      for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}\n                    }\n                  }\n                  if (width) {\n                    if ((className = getClass.call(width)) == numberClass) {\n                      // Convert the `width` to an integer and create a string containing\n                      // `width` number of space characters.\n                      if ((width -= width % 1) > 0) {\n                        for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \") {}\n                      }\n                    } else if (className == stringClass) {\n                      whitespace = width.length <= 10 ? width : width.slice(0, 10);\n                    }\n                  }\n                  // Opera <= 7.54u2 discards the values associated with empty string keys\n                  // (`\"\"`) only if they are used directly within an object member list\n                  // (e.g., `!(\"\" in { \"\": 1})`).\n                  return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n                };\n              }\n\n              // Public: Parses a JSON source string.\n              if (!has(\"json-parse\")) {\n                var fromCharCode = String.fromCharCode;\n\n                // Internal: A map of escaped control characters and their unescaped\n                // equivalents.\n                var Unescapes = {\n                  92: \"\\\\\",\n                  34: '\"',\n                  47: \"/\",\n                  98: \"\\b\",\n                  116: \"\\t\",\n                  110: \"\\n\",\n                  102: \"\\f\",\n                  114: \"\\r\"\n                };\n\n                // Internal: Stores the parser state.\n                var Index, Source;\n\n                // Internal: Resets the parser state and throws a `SyntaxError`.\n                var abort = function abort() {\n                  Index = Source = null;\n                  throw SyntaxError();\n                };\n\n                // Internal: Returns the next token, or `\"$\"` if the parser has reached\n                // the end of the source string. A token may be a string, number, `null`\n                // literal, or Boolean literal.\n                var lex = function lex() {\n                  var source = Source,\n                      length = source.length,\n                      value,\n                      begin,\n                      position,\n                      isSigned,\n                      charCode;\n                  while (Index < length) {\n                    charCode = source.charCodeAt(Index);\n                    switch (charCode) {\n                      case 9:case 10:case 13:case 32:\n                        // Skip whitespace tokens, including tabs, carriage returns, line\n                        // feeds, and space characters.\n                        Index++;\n                        break;\n                      case 123:case 125:case 91:case 93:case 58:case 44:\n                        // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                        // the current position.\n                        value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                        Index++;\n                        return value;\n                      case 34:\n                        // `\"` delimits a JSON string; advance to the next character and\n                        // begin parsing the string. String tokens are prefixed with the\n                        // sentinel `@` character to distinguish them from punctuators and\n                        // end-of-string tokens.\n                        for (value = \"@\", Index++; Index < length;) {\n                          charCode = source.charCodeAt(Index);\n                          if (charCode < 32) {\n                            // Unescaped ASCII control characters (those with a code unit\n                            // less than the space character) are not permitted.\n                            abort();\n                          } else if (charCode == 92) {\n                            // A reverse solidus (`\\`) marks the beginning of an escaped\n                            // control character (including `\"`, `\\`, and `/`) or Unicode\n                            // escape sequence.\n                            charCode = source.charCodeAt(++Index);\n                            switch (charCode) {\n                              case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:\n                                // Revive escaped control characters.\n                                value += Unescapes[charCode];\n                                Index++;\n                                break;\n                              case 117:\n                                // `\\u` marks the beginning of a Unicode escape sequence.\n                                // Advance to the first character and validate the\n                                // four-digit code point.\n                                begin = ++Index;\n                                for (position = Index + 4; Index < position; Index++) {\n                                  charCode = source.charCodeAt(Index);\n                                  // A valid sequence comprises four hexdigits (case-\n                                  // insensitive) that form a single hexadecimal value.\n                                  if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                                    // Invalid Unicode escape sequence.\n                                    abort();\n                                  }\n                                }\n                                // Revive the escaped character.\n                                value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                                break;\n                              default:\n                                // Invalid escape sequence.\n                                abort();\n                            }\n                          } else {\n                            if (charCode == 34) {\n                              // An unescaped double-quote character marks the end of the\n                              // string.\n                              break;\n                            }\n                            charCode = source.charCodeAt(Index);\n                            begin = Index;\n                            // Optimize for the common case where a string is valid.\n                            while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                              charCode = source.charCodeAt(++Index);\n                            }\n                            // Append the string as-is.\n                            value += source.slice(begin, Index);\n                          }\n                        }\n                        if (source.charCodeAt(Index) == 34) {\n                          // Advance to the next character and return the revived string.\n                          Index++;\n                          return value;\n                        }\n                        // Unterminated string.\n                        abort();\n                      default:\n                        // Parse numbers and literals.\n                        begin = Index;\n                        // Advance past the negative sign, if one is specified.\n                        if (charCode == 45) {\n                          isSigned = true;\n                          charCode = source.charCodeAt(++Index);\n                        }\n                        // Parse an integer or floating-point value.\n                        if (charCode >= 48 && charCode <= 57) {\n                          // Leading zeroes are interpreted as octal literals.\n                          if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {\n                            // Illegal octal literal.\n                            abort();\n                          }\n                          isSigned = false;\n                          // Parse the integer component.\n                          for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}\n                          // Floats cannot contain a leading decimal point; however, this\n                          // case is already accounted for by the parser.\n                          if (source.charCodeAt(Index) == 46) {\n                            position = ++Index;\n                            // Parse the decimal component.\n                            for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}\n                            if (position == Index) {\n                              // Illegal trailing decimal.\n                              abort();\n                            }\n                            Index = position;\n                          }\n                          // Parse exponents. The `e` denoting the exponent is\n                          // case-insensitive.\n                          charCode = source.charCodeAt(Index);\n                          if (charCode == 101 || charCode == 69) {\n                            charCode = source.charCodeAt(++Index);\n                            // Skip past the sign following the exponent, if one is\n                            // specified.\n                            if (charCode == 43 || charCode == 45) {\n                              Index++;\n                            }\n                            // Parse the exponential component.\n                            for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}\n                            if (position == Index) {\n                              // Illegal empty exponent.\n                              abort();\n                            }\n                            Index = position;\n                          }\n                          // Coerce the parsed value to a JavaScript number.\n                          return +source.slice(begin, Index);\n                        }\n                        // A negative sign may only precede numbers.\n                        if (isSigned) {\n                          abort();\n                        }\n                        // `true`, `false`, and `null` literals.\n                        if (source.slice(Index, Index + 4) == \"true\") {\n                          Index += 4;\n                          return true;\n                        } else if (source.slice(Index, Index + 5) == \"false\") {\n                          Index += 5;\n                          return false;\n                        } else if (source.slice(Index, Index + 4) == \"null\") {\n                          Index += 4;\n                          return null;\n                        }\n                        // Unrecognized token.\n                        abort();\n                    }\n                  }\n                  // Return the sentinel `$` character if the parser has reached the end\n                  // of the source string.\n                  return \"$\";\n                };\n\n                // Internal: Parses a JSON `value` token.\n                var get = function get(value) {\n                  var results, hasMembers;\n                  if (value == \"$\") {\n                    // Unexpected end of input.\n                    abort();\n                  }\n                  if (typeof value == \"string\") {\n                    if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n                      // Remove the sentinel `@` character.\n                      return value.slice(1);\n                    }\n                    // Parse object and array literals.\n                    if (value == \"[\") {\n                      // Parses a JSON array, returning a new JavaScript array.\n                      results = [];\n                      for (;; hasMembers || (hasMembers = true)) {\n                        value = lex();\n                        // A closing square bracket marks the end of the array literal.\n                        if (value == \"]\") {\n                          break;\n                        }\n                        // If the array literal contains elements, the current token\n                        // should be a comma separating the previous element from the\n                        // next.\n                        if (hasMembers) {\n                          if (value == \",\") {\n                            value = lex();\n                            if (value == \"]\") {\n                              // Unexpected trailing `,` in array literal.\n                              abort();\n                            }\n                          } else {\n                            // A `,` must separate each array element.\n                            abort();\n                          }\n                        }\n                        // Elisions and leading commas are not permitted.\n                        if (value == \",\") {\n                          abort();\n                        }\n                        results.push(get(value));\n                      }\n                      return results;\n                    } else if (value == \"{\") {\n                      // Parses a JSON object, returning a new JavaScript object.\n                      results = {};\n                      for (;; hasMembers || (hasMembers = true)) {\n                        value = lex();\n                        // A closing curly brace marks the end of the object literal.\n                        if (value == \"}\") {\n                          break;\n                        }\n                        // If the object literal contains members, the current token\n                        // should be a comma separator.\n                        if (hasMembers) {\n                          if (value == \",\") {\n                            value = lex();\n                            if (value == \"}\") {\n                              // Unexpected trailing `,` in object literal.\n                              abort();\n                            }\n                          } else {\n                            // A `,` must separate each object member.\n                            abort();\n                          }\n                        }\n                        // Leading commas are not permitted, object property names must be\n                        // double-quoted strings, and a `:` must separate each property\n                        // name and value.\n                        if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                          abort();\n                        }\n                        results[value.slice(1)] = get(lex());\n                      }\n                      return results;\n                    }\n                    // Unexpected token encountered.\n                    abort();\n                  }\n                  return value;\n                };\n\n                // Internal: Updates a traversed object member.\n                var update = function update(source, property, callback) {\n                  var element = walk(source, property, callback);\n                  if (element === undef) {\n                    delete source[property];\n                  } else {\n                    source[property] = element;\n                  }\n                };\n\n                // Internal: Recursively traverses a parsed JSON object, invoking the\n                // `callback` function for each value. This is an implementation of the\n                // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n                var walk = function walk(source, property, callback) {\n                  var value = source[property],\n                      length;\n                  if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) == \"object\" && value) {\n                    // `forEach` can't be used to traverse an array in Opera <= 8.54\n                    // because its `Object#hasOwnProperty` implementation returns `false`\n                    // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n                    if (getClass.call(value) == arrayClass) {\n                      for (length = value.length; length--;) {\n                        update(value, length, callback);\n                      }\n                    } else {\n                      _forEach(value, function (property) {\n                        update(value, property, callback);\n                      });\n                    }\n                  }\n                  return callback.call(source, property, value);\n                };\n\n                // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n                exports.parse = function (source, callback) {\n                  var result, value;\n                  Index = 0;\n                  Source = \"\" + source;\n                  result = get(lex());\n                  // If a JSON string contains multiple tokens, it is invalid.\n                  if (lex() != \"$\") {\n                    abort();\n                  }\n                  // Reset the parser state.\n                  Index = Source = null;\n                  return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n                };\n              }\n            }\n\n            exports[\"runInContext\"] = runInContext;\n            return exports;\n          }\n\n          if (freeExports && !isLoader) {\n            // Export for CommonJS environments.\n            runInContext(root, freeExports);\n          } else {\n            // Export for web browsers and JavaScript engines.\n            var nativeJSON = root.JSON,\n                previousJSON = root[\"JSON3\"],\n                isRestored = false;\n\n            var JSON3 = runInContext(root, root[\"JSON3\"] = {\n              // Public: Restores the original value of the global `JSON` object and\n              // returns a reference to the `JSON3` object.\n              \"noConflict\": function noConflict() {\n                if (!isRestored) {\n                  isRestored = true;\n                  root.JSON = nativeJSON;\n                  root[\"JSON3\"] = previousJSON;\n                  nativeJSON = previousJSON = null;\n                }\n                return JSON3;\n              }\n            });\n\n            root.JSON = {\n              \"parse\": JSON3.parse,\n              \"stringify\": JSON3.stringify\n            };\n          }\n\n          // Export for asynchronous module loaders.\n          if (isLoader) {\n            define(function () {\n              return JSON3;\n            });\n          }\n        }).call(this);\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, {}], 35: [function (_dereq_, module, exports) {\n      /**\n       * Helpers.\n       */\n\n      var s = 1000;\n      var m = s * 60;\n      var h = m * 60;\n      var d = h * 24;\n      var y = d * 365.25;\n\n      /**\n       * Parse or format the given `val`.\n       *\n       * Options:\n       *\n       *  - `long` verbose formatting [false]\n       *\n       * @param {String|Number} val\n       * @param {Object} options\n       * @return {String|Number}\n       * @api public\n       */\n\n      module.exports = function (val, options) {\n        options = options || {};\n        if ('string' == typeof val) return parse(val);\n        return options.long ? long(val) : short(val);\n      };\n\n      /**\n       * Parse the given `str` and return milliseconds.\n       *\n       * @param {String} str\n       * @return {Number}\n       * @api private\n       */\n\n      function parse(str) {\n        str = '' + str;\n        if (str.length > 10000) return;\n        var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n        if (!match) return;\n        var n = parseFloat(match[1]);\n        var type = (match[2] || 'ms').toLowerCase();\n        switch (type) {\n          case 'years':\n          case 'year':\n          case 'yrs':\n          case 'yr':\n          case 'y':\n            return n * y;\n          case 'days':\n          case 'day':\n          case 'd':\n            return n * d;\n          case 'hours':\n          case 'hour':\n          case 'hrs':\n          case 'hr':\n          case 'h':\n            return n * h;\n          case 'minutes':\n          case 'minute':\n          case 'mins':\n          case 'min':\n          case 'm':\n            return n * m;\n          case 'seconds':\n          case 'second':\n          case 'secs':\n          case 'sec':\n          case 's':\n            return n * s;\n          case 'milliseconds':\n          case 'millisecond':\n          case 'msecs':\n          case 'msec':\n          case 'ms':\n            return n;\n        }\n      }\n\n      /**\n       * Short format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n      function short(ms) {\n        if (ms >= d) return Math.round(ms / d) + 'd';\n        if (ms >= h) return Math.round(ms / h) + 'h';\n        if (ms >= m) return Math.round(ms / m) + 'm';\n        if (ms >= s) return Math.round(ms / s) + 's';\n        return ms + 'ms';\n      }\n\n      /**\n       * Long format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n      function long(ms) {\n        return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n      }\n\n      /**\n       * Pluralization helper.\n       */\n\n      function plural(ms, n, name) {\n        if (ms < n) return;\n        if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n        return Math.ceil(ms / n) + ' ' + name + 's';\n      }\n    }, {}], 36: [function (_dereq_, module, exports) {\n      (function (global) {\n        /**\n         * JSON parse.\n         *\n         * @see Based on jQuery#parseJSON (MIT) and JSON2\n         * @api private\n         */\n\n        var rvalidchars = /^[\\],:{}\\s]*$/;\n        var rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\n        var rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n        var rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g;\n        var rtrimLeft = /^\\s+/;\n        var rtrimRight = /\\s+$/;\n\n        module.exports = function parsejson(data) {\n          if ('string' != typeof data || !data) {\n            return null;\n          }\n\n          data = data.replace(rtrimLeft, '').replace(rtrimRight, '');\n\n          // Attempt to parse using the native JSON parser first\n          if (global.JSON && JSON.parse) {\n            return JSON.parse(data);\n          }\n\n          if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {\n            return new Function('return ' + data)();\n          }\n        };\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, {}], 37: [function (_dereq_, module, exports) {\n      /**\n       * Compiles a querystring\n       * Returns string representation of the object\n       *\n       * @param {Object}\n       * @api private\n       */\n\n      exports.encode = function (obj) {\n        var str = '';\n\n        for (var i in obj) {\n          if (obj.hasOwnProperty(i)) {\n            if (str.length) str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n          }\n        }\n\n        return str;\n      };\n\n      /**\n       * Parses a simple querystring into an object\n       *\n       * @param {String} qs\n       * @api private\n       */\n\n      exports.decode = function (qs) {\n        var qry = {};\n        var pairs = qs.split('&');\n        for (var i = 0, l = pairs.length; i < l; i++) {\n          var pair = pairs[i].split('=');\n          qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n        return qry;\n      };\n    }, {}], 38: [function (_dereq_, module, exports) {\n      /**\n       * Parses an URI\n       *\n       * @author Steven Levithan <stevenlevithan.com> (MIT license)\n       * @api private\n       */\n\n      var re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\n      var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];\n\n      module.exports = function parseuri(str) {\n        var src = str,\n            b = str.indexOf('['),\n            e = str.indexOf(']');\n\n        if (b != -1 && e != -1) {\n          str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n        }\n\n        var m = re.exec(str || ''),\n            uri = {},\n            i = 14;\n\n        while (i--) {\n          uri[parts[i]] = m[i] || '';\n        }\n\n        if (b != -1 && e != -1) {\n          uri.source = src;\n          uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n          uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n          uri.ipv6uri = true;\n        }\n\n        return uri;\n      };\n    }, {}], 39: [function (_dereq_, module, exports) {\n      (function (global) {\n        /*global Blob,File*/\n\n        /**\n         * Module requirements\n         */\n\n        var isArray = _dereq_('isarray');\n        var isBuf = _dereq_('./is-buffer');\n\n        /**\n         * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n         * Anything with blobs or files should be fed through removeBlobs before coming\n         * here.\n         *\n         * @param {Object} packet - socket.io event packet\n         * @return {Object} with deconstructed packet and list of buffers\n         * @api public\n         */\n\n        exports.deconstructPacket = function (packet) {\n          var buffers = [];\n          var packetData = packet.data;\n\n          function _deconstructPacket(data) {\n            if (!data) return data;\n\n            if (isBuf(data)) {\n              var placeholder = { _placeholder: true, num: buffers.length };\n              buffers.push(data);\n              return placeholder;\n            } else if (isArray(data)) {\n              var newData = new Array(data.length);\n              for (var i = 0; i < data.length; i++) {\n                newData[i] = _deconstructPacket(data[i]);\n              }\n              return newData;\n            } else if ('object' == (typeof data === \"undefined\" ? \"undefined\" : _typeof(data)) && !(data instanceof Date)) {\n              var newData = {};\n              for (var key in data) {\n                newData[key] = _deconstructPacket(data[key]);\n              }\n              return newData;\n            }\n            return data;\n          }\n\n          var pack = packet;\n          pack.data = _deconstructPacket(packetData);\n          pack.attachments = buffers.length; // number of binary 'attachments'\n          return { packet: pack, buffers: buffers };\n        };\n\n        /**\n         * Reconstructs a binary packet from its placeholder packet and buffers\n         *\n         * @param {Object} packet - event packet with placeholders\n         * @param {Array} buffers - binary buffers to put in placeholder positions\n         * @return {Object} reconstructed packet\n         * @api public\n         */\n\n        exports.reconstructPacket = function (packet, buffers) {\n          var curPlaceHolder = 0;\n\n          function _reconstructPacket(data) {\n            if (data && data._placeholder) {\n              var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n              return buf;\n            } else if (isArray(data)) {\n              for (var i = 0; i < data.length; i++) {\n                data[i] = _reconstructPacket(data[i]);\n              }\n              return data;\n            } else if (data && 'object' == (typeof data === \"undefined\" ? \"undefined\" : _typeof(data))) {\n              for (var key in data) {\n                data[key] = _reconstructPacket(data[key]);\n              }\n              return data;\n            }\n            return data;\n          }\n\n          packet.data = _reconstructPacket(packet.data);\n          packet.attachments = undefined; // no longer useful\n          return packet;\n        };\n\n        /**\n         * Asynchronously removes Blobs or Files from data via\n         * FileReader's readAsArrayBuffer method. Used before encoding\n         * data as msgpack. Calls callback with the blobless data.\n         *\n         * @param {Object} data\n         * @param {Function} callback\n         * @api private\n         */\n\n        exports.removeBlobs = function (data, callback) {\n          function _removeBlobs(obj, curKey, containingObject) {\n            if (!obj) return obj;\n\n            // convert any blob\n            if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {\n              pendingBlobs++;\n\n              // async filereader\n              var fileReader = new FileReader();\n              fileReader.onload = function () {\n                // this.result == arraybuffer\n                if (containingObject) {\n                  containingObject[curKey] = this.result;\n                } else {\n                  bloblessData = this.result;\n                }\n\n                // if nothing pending its callback time\n                if (! --pendingBlobs) {\n                  callback(bloblessData);\n                }\n              };\n\n              fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n            } else if (isArray(obj)) {\n              // handle array\n              for (var i = 0; i < obj.length; i++) {\n                _removeBlobs(obj[i], i, obj);\n              }\n            } else if (obj && 'object' == (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) && !isBuf(obj)) {\n              // and object\n              for (var key in obj) {\n                _removeBlobs(obj[key], key, obj);\n              }\n            }\n          }\n\n          var pendingBlobs = 0;\n          var bloblessData = data;\n          _removeBlobs(bloblessData);\n          if (!pendingBlobs) {\n            callback(bloblessData);\n          }\n        };\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, { \"./is-buffer\": 41, \"isarray\": 33 }], 40: [function (_dereq_, module, exports) {\n\n      /**\n       * Module dependencies.\n       */\n\n      var debug = _dereq_('debug')('socket.io-parser');\n      var json = _dereq_('json3');\n      var isArray = _dereq_('isarray');\n      var Emitter = _dereq_('component-emitter');\n      var binary = _dereq_('./binary');\n      var isBuf = _dereq_('./is-buffer');\n\n      /**\n       * Protocol version.\n       *\n       * @api public\n       */\n\n      exports.protocol = 4;\n\n      /**\n       * Packet types.\n       *\n       * @api public\n       */\n\n      exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];\n\n      /**\n       * Packet type `connect`.\n       *\n       * @api public\n       */\n\n      exports.CONNECT = 0;\n\n      /**\n       * Packet type `disconnect`.\n       *\n       * @api public\n       */\n\n      exports.DISCONNECT = 1;\n\n      /**\n       * Packet type `event`.\n       *\n       * @api public\n       */\n\n      exports.EVENT = 2;\n\n      /**\n       * Packet type `ack`.\n       *\n       * @api public\n       */\n\n      exports.ACK = 3;\n\n      /**\n       * Packet type `error`.\n       *\n       * @api public\n       */\n\n      exports.ERROR = 4;\n\n      /**\n       * Packet type 'binary event'\n       *\n       * @api public\n       */\n\n      exports.BINARY_EVENT = 5;\n\n      /**\n       * Packet type `binary ack`. For acks with binary arguments.\n       *\n       * @api public\n       */\n\n      exports.BINARY_ACK = 6;\n\n      /**\n       * Encoder constructor.\n       *\n       * @api public\n       */\n\n      exports.Encoder = Encoder;\n\n      /**\n       * Decoder constructor.\n       *\n       * @api public\n       */\n\n      exports.Decoder = Decoder;\n\n      /**\n       * A socket.io Encoder instance\n       *\n       * @api public\n       */\n\n      function Encoder() {}\n\n      /**\n       * Encode a packet as a single string if non-binary, or as a\n       * buffer sequence, depending on packet type.\n       *\n       * @param {Object} obj - packet object\n       * @param {Function} callback - function to handle encodings (likely engine.write)\n       * @return Calls callback with Array of encodings\n       * @api public\n       */\n\n      Encoder.prototype.encode = function (obj, callback) {\n        debug('encoding packet %j', obj);\n\n        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n          encodeAsBinary(obj, callback);\n        } else {\n          var encoding = encodeAsString(obj);\n          callback([encoding]);\n        }\n      };\n\n      /**\n       * Encode packet as string.\n       *\n       * @param {Object} packet\n       * @return {String} encoded\n       * @api private\n       */\n\n      function encodeAsString(obj) {\n        var str = '';\n        var nsp = false;\n\n        // first is type\n        str += obj.type;\n\n        // attachments if we have them\n        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n          str += obj.attachments;\n          str += '-';\n        }\n\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && '/' != obj.nsp) {\n          nsp = true;\n          str += obj.nsp;\n        }\n\n        // immediately followed by the id\n        if (null != obj.id) {\n          if (nsp) {\n            str += ',';\n            nsp = false;\n          }\n          str += obj.id;\n        }\n\n        // json data\n        if (null != obj.data) {\n          if (nsp) str += ',';\n          str += json.stringify(obj.data);\n        }\n\n        debug('encoded %j as %s', obj, str);\n        return str;\n      }\n\n      /**\n       * Encode packet as 'buffer sequence' by removing blobs, and\n       * deconstructing packet into object with placeholders and\n       * a list of buffers.\n       *\n       * @param {Object} packet\n       * @return {Buffer} encoded\n       * @api private\n       */\n\n      function encodeAsBinary(obj, callback) {\n\n        function writeEncoding(bloblessData) {\n          var deconstruction = binary.deconstructPacket(bloblessData);\n          var pack = encodeAsString(deconstruction.packet);\n          var buffers = deconstruction.buffers;\n\n          buffers.unshift(pack); // add packet info to beginning of data list\n          callback(buffers); // write all the buffers\n        }\n\n        binary.removeBlobs(obj, writeEncoding);\n      }\n\n      /**\n       * A socket.io Decoder instance\n       *\n       * @return {Object} decoder\n       * @api public\n       */\n\n      function Decoder() {\n        this.reconstructor = null;\n      }\n\n      /**\n       * Mix in `Emitter` with Decoder.\n       */\n\n      Emitter(Decoder.prototype);\n\n      /**\n       * Decodes an ecoded packet string into packet JSON.\n       *\n       * @param {String} obj - encoded packet\n       * @return {Object} packet\n       * @api public\n       */\n\n      Decoder.prototype.add = function (obj) {\n        var packet;\n        if ('string' == typeof obj) {\n          packet = decodeString(obj);\n          if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {\n            // binary packet's json\n            this.reconstructor = new BinaryReconstructor(packet);\n\n            // no attachments, labeled binary but no binary data to follow\n            if (this.reconstructor.reconPack.attachments === 0) {\n              this.emit('decoded', packet);\n            }\n          } else {\n            // non-binary full packet\n            this.emit('decoded', packet);\n          }\n        } else if (isBuf(obj) || obj.base64) {\n          // raw binary data\n          if (!this.reconstructor) {\n            throw new Error('got binary data when not reconstructing a packet');\n          } else {\n            packet = this.reconstructor.takeBinaryData(obj);\n            if (packet) {\n              // received final buffer\n              this.reconstructor = null;\n              this.emit('decoded', packet);\n            }\n          }\n        } else {\n          throw new Error('Unknown type: ' + obj);\n        }\n      };\n\n      /**\n       * Decode a packet String (JSON data)\n       *\n       * @param {String} str\n       * @return {Object} packet\n       * @api private\n       */\n\n      function decodeString(str) {\n        var p = {};\n        var i = 0;\n\n        // look up type\n        p.type = Number(str.charAt(0));\n        if (null == exports.types[p.type]) return error();\n\n        // look up attachments if type binary\n        if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n          var buf = '';\n          while (str.charAt(++i) != '-') {\n            buf += str.charAt(i);\n            if (i == str.length) break;\n          }\n          if (buf != Number(buf) || str.charAt(i) != '-') {\n            throw new Error('Illegal attachments');\n          }\n          p.attachments = Number(buf);\n        }\n\n        // look up namespace (if any)\n        if ('/' == str.charAt(i + 1)) {\n          p.nsp = '';\n          while (++i) {\n            var c = str.charAt(i);\n            if (',' == c) break;\n            p.nsp += c;\n            if (i == str.length) break;\n          }\n        } else {\n          p.nsp = '/';\n        }\n\n        // look up id\n        var next = str.charAt(i + 1);\n        if ('' !== next && Number(next) == next) {\n          p.id = '';\n          while (++i) {\n            var c = str.charAt(i);\n            if (null == c || Number(c) != c) {\n              --i;\n              break;\n            }\n            p.id += str.charAt(i);\n            if (i == str.length) break;\n          }\n          p.id = Number(p.id);\n        }\n\n        // look up json data\n        if (str.charAt(++i)) {\n          try {\n            p.data = json.parse(str.substr(i));\n          } catch (e) {\n            return error();\n          }\n        }\n\n        debug('decoded %s as %j', str, p);\n        return p;\n      }\n\n      /**\n       * Deallocates a parser's resources\n       *\n       * @api public\n       */\n\n      Decoder.prototype.destroy = function () {\n        if (this.reconstructor) {\n          this.reconstructor.finishedReconstruction();\n        }\n      };\n\n      /**\n       * A manager of a binary event's 'buffer sequence'. Should\n       * be constructed whenever a packet of type BINARY_EVENT is\n       * decoded.\n       *\n       * @param {Object} packet\n       * @return {BinaryReconstructor} initialized reconstructor\n       * @api private\n       */\n\n      function BinaryReconstructor(packet) {\n        this.reconPack = packet;\n        this.buffers = [];\n      }\n\n      /**\n       * Method to be called when binary data received from connection\n       * after a BINARY_EVENT packet.\n       *\n       * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n       * @return {null | Object} returns null if more binary data is expected or\n       *   a reconstructed packet object if all buffers have been received.\n       * @api private\n       */\n\n      BinaryReconstructor.prototype.takeBinaryData = function (binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length == this.reconPack.attachments) {\n          // done with buffer list\n          var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n          this.finishedReconstruction();\n          return packet;\n        }\n        return null;\n      };\n\n      /**\n       * Cleans up binary packet reconstruction variables.\n       *\n       * @api private\n       */\n\n      BinaryReconstructor.prototype.finishedReconstruction = function () {\n        this.reconPack = null;\n        this.buffers = [];\n      };\n\n      function error(data) {\n        return {\n          type: exports.ERROR,\n          data: 'parser error'\n        };\n      }\n    }, { \"./binary\": 39, \"./is-buffer\": 41, \"component-emitter\": 42, \"debug\": 14, \"isarray\": 33, \"json3\": 34 }], 41: [function (_dereq_, module, exports) {\n      (function (global) {\n\n        module.exports = isBuf;\n\n        /**\n         * Returns true if obj is a buffer or an arraybuffer.\n         *\n         * @api private\n         */\n\n        function isBuf(obj) {\n          return global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;\n        }\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, {}], 42: [function (_dereq_, module, exports) {\n      arguments[4][26][0].apply(exports, arguments);\n    }, { \"dup\": 26 }], 43: [function (_dereq_, module, exports) {\n      module.exports = toArray;\n\n      function toArray(list, index) {\n        var array = [];\n\n        index = index || 0;\n\n        for (var i = index || 0; i < list.length; i++) {\n          array[i - index] = list[i];\n        }\n\n        return array;\n      }\n    }, {}], 44: [function (_dereq_, module, exports) {\n      (function (global) {\n        /*! https://mths.be/utf8js v2.0.0 by @mathias */\n        ;(function (root) {\n\n          // Detect free variables `exports`\n          var freeExports = (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) == 'object' && exports;\n\n          // Detect free variable `module`\n          var freeModule = (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) == 'object' && module && module.exports == freeExports && module;\n\n          // Detect free variable `global`, from Node.js or Browserified code,\n          // and use it as `root`\n          var freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global;\n          if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n            root = freeGlobal;\n          }\n\n          /*--------------------------------------------------------------------------*/\n\n          var stringFromCharCode = String.fromCharCode;\n\n          // Taken from https://mths.be/punycode\n          function ucs2decode(string) {\n            var output = [];\n            var counter = 0;\n            var length = string.length;\n            var value;\n            var extra;\n            while (counter < length) {\n              value = string.charCodeAt(counter++);\n              if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // high surrogate, and there is a next character\n                extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {\n                  // low surrogate\n                  output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                  // unmatched surrogate; only append this code unit, in case the next\n                  // code unit is the high surrogate of a surrogate pair\n                  output.push(value);\n                  counter--;\n                }\n              } else {\n                output.push(value);\n              }\n            }\n            return output;\n          }\n\n          // Taken from https://mths.be/punycode\n          function ucs2encode(array) {\n            var length = array.length;\n            var index = -1;\n            var value;\n            var output = '';\n            while (++index < length) {\n              value = array[index];\n              if (value > 0xFFFF) {\n                value -= 0x10000;\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                value = 0xDC00 | value & 0x3FF;\n              }\n              output += stringFromCharCode(value);\n            }\n            return output;\n          }\n\n          function checkScalarValue(codePoint) {\n            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n              throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');\n            }\n          }\n          /*--------------------------------------------------------------------------*/\n\n          function createByte(codePoint, shift) {\n            return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);\n          }\n\n          function encodeCodePoint(codePoint) {\n            if ((codePoint & 0xFFFFFF80) == 0) {\n              // 1-byte sequence\n              return stringFromCharCode(codePoint);\n            }\n            var symbol = '';\n            if ((codePoint & 0xFFFFF800) == 0) {\n              // 2-byte sequence\n              symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);\n            } else if ((codePoint & 0xFFFF0000) == 0) {\n              // 3-byte sequence\n              checkScalarValue(codePoint);\n              symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);\n              symbol += createByte(codePoint, 6);\n            } else if ((codePoint & 0xFFE00000) == 0) {\n              // 4-byte sequence\n              symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);\n              symbol += createByte(codePoint, 12);\n              symbol += createByte(codePoint, 6);\n            }\n            symbol += stringFromCharCode(codePoint & 0x3F | 0x80);\n            return symbol;\n          }\n\n          function utf8encode(string) {\n            var codePoints = ucs2decode(string);\n            var length = codePoints.length;\n            var index = -1;\n            var codePoint;\n            var byteString = '';\n            while (++index < length) {\n              codePoint = codePoints[index];\n              byteString += encodeCodePoint(codePoint);\n            }\n            return byteString;\n          }\n\n          /*--------------------------------------------------------------------------*/\n\n          function readContinuationByte() {\n            if (byteIndex >= byteCount) {\n              throw Error('Invalid byte index');\n            }\n\n            var continuationByte = byteArray[byteIndex] & 0xFF;\n            byteIndex++;\n\n            if ((continuationByte & 0xC0) == 0x80) {\n              return continuationByte & 0x3F;\n            }\n\n            // If we end up here, it’s not a continuation byte\n            throw Error('Invalid continuation byte');\n          }\n\n          function decodeSymbol() {\n            var byte1;\n            var byte2;\n            var byte3;\n            var byte4;\n            var codePoint;\n\n            if (byteIndex > byteCount) {\n              throw Error('Invalid byte index');\n            }\n\n            if (byteIndex == byteCount) {\n              return false;\n            }\n\n            // Read first byte\n            byte1 = byteArray[byteIndex] & 0xFF;\n            byteIndex++;\n\n            // 1-byte sequence (no continuation bytes)\n            if ((byte1 & 0x80) == 0) {\n              return byte1;\n            }\n\n            // 2-byte sequence\n            if ((byte1 & 0xE0) == 0xC0) {\n              var byte2 = readContinuationByte();\n              codePoint = (byte1 & 0x1F) << 6 | byte2;\n              if (codePoint >= 0x80) {\n                return codePoint;\n              } else {\n                throw Error('Invalid continuation byte');\n              }\n            }\n\n            // 3-byte sequence (may include unpaired surrogates)\n            if ((byte1 & 0xF0) == 0xE0) {\n              byte2 = readContinuationByte();\n              byte3 = readContinuationByte();\n              codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;\n              if (codePoint >= 0x0800) {\n                checkScalarValue(codePoint);\n                return codePoint;\n              } else {\n                throw Error('Invalid continuation byte');\n              }\n            }\n\n            // 4-byte sequence\n            if ((byte1 & 0xF8) == 0xF0) {\n              byte2 = readContinuationByte();\n              byte3 = readContinuationByte();\n              byte4 = readContinuationByte();\n              codePoint = (byte1 & 0x0F) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;\n              if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n                return codePoint;\n              }\n            }\n\n            throw Error('Invalid UTF-8 detected');\n          }\n\n          var byteArray;\n          var byteCount;\n          var byteIndex;\n          function utf8decode(byteString) {\n            byteArray = ucs2decode(byteString);\n            byteCount = byteArray.length;\n            byteIndex = 0;\n            var codePoints = [];\n            var tmp;\n            while ((tmp = decodeSymbol()) !== false) {\n              codePoints.push(tmp);\n            }\n            return ucs2encode(codePoints);\n          }\n\n          /*--------------------------------------------------------------------------*/\n\n          var utf8 = {\n            'version': '2.0.0',\n            'encode': utf8encode,\n            'decode': utf8decode\n          };\n\n          // Some AMD build optimizers, like r.js, check for specific condition patterns\n          // like the following:\n          if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {\n            define(function () {\n              return utf8;\n            });\n          } else if (freeExports && !freeExports.nodeType) {\n            if (freeModule) {\n              // in Node.js or RingoJS v0.8.0+\n              freeModule.exports = utf8;\n            } else {\n              // in Narwhal or RingoJS v0.7.0-\n              var object = {};\n              var hasOwnProperty = object.hasOwnProperty;\n              for (var key in utf8) {\n                hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n              }\n            }\n          } else {\n            // in Rhino or a web browser\n            root.utf8 = utf8;\n          }\n        })(this);\n      }).call(this, typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n    }, {}], 45: [function (_dereq_, module, exports) {\n      'use strict';\n\n      var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),\n          length = 64,\n          map = {},\n          seed = 0,\n          i = 0,\n          prev;\n\n      /**\n       * Return a string representing the specified number.\n       *\n       * @param {Number} num The number to convert.\n       * @returns {String} The string representation of the number.\n       * @api public\n       */\n      function encode(num) {\n        var encoded = '';\n\n        do {\n          encoded = alphabet[num % length] + encoded;\n          num = Math.floor(num / length);\n        } while (num > 0);\n\n        return encoded;\n      }\n\n      /**\n       * Return the integer value specified by the given string.\n       *\n       * @param {String} str The string to convert.\n       * @returns {Number} The integer value represented by the string.\n       * @api public\n       */\n      function decode(str) {\n        var decoded = 0;\n\n        for (i = 0; i < str.length; i++) {\n          decoded = decoded * length + map[str.charAt(i)];\n        }\n\n        return decoded;\n      }\n\n      /**\n       * Yeast: A tiny growing id generator.\n       *\n       * @returns {String} A unique id.\n       * @api public\n       */\n      function yeast() {\n        var now = encode(+new Date());\n\n        if (now !== prev) return seed = 0, prev = now;\n        return now + '.' + encode(seed++);\n      }\n\n      //\n      // Map each character to its index.\n      //\n      for (; i < length; i++) {\n        map[alphabet[i]] = i;\n      } //\n      // Expose the `yeast`, `encode` and `decode` functions.\n      //\n      yeast.encode = encode;\n      yeast.decode = decode;\n      module.exports = yeast;\n    }, {}] }, {}, [1])(1);\n});\n\ncc._RF.pop();\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnJhcnkvaW1wb3J0cy8yNS8yNWY2MjkzYi03OThiLTQzOGUtYWVhMy05YWE5ZjhiYmQ0M2YuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jYy5fUkYucHVzaChtb2R1bGUsICcyNWY2Mms3ZVl0RGpxNmptcW40dTlRLycsICdzb2NrZXQuaW8nKTtcbi8vIHNjcmlwdC90b29sL3NvY2tldC5pby5qc1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4oZnVuY3Rpb24gKGYpIHtcbiAgaWYgKCh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGV4cG9ydHMpKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGYpO1xuICB9IGVsc2Uge1xuICAgIHZhciBnO2lmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBnID0gd2luZG93O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZyA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBnID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgZyA9IHRoaXM7XG4gICAgfWcuaW8gPSBmKCk7XG4gIH1cbn0pKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRlZmluZSwgbW9kdWxlLCBleHBvcnRzO3JldHVybiBmdW5jdGlvbiBlKHQsIG4sIHIpIHtcbiAgICBmdW5jdGlvbiBzKG8sIHUpIHtcbiAgICAgIGlmICghbltvXSkge1xuICAgICAgICBpZiAoIXRbb10pIHtcbiAgICAgICAgICB2YXIgYSA9IHR5cGVvZiByZXF1aXJlID09IFwiZnVuY3Rpb25cIiAmJiByZXF1aXJlO2lmICghdSAmJiBhKSByZXR1cm4gYShvLCAhMCk7aWYgKGkpIHJldHVybiBpKG8sICEwKTt2YXIgZiA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyBvICsgXCInXCIpO3Rocm93IGYuY29kZSA9IFwiTU9EVUxFX05PVF9GT1VORFwiLCBmO1xuICAgICAgICB9dmFyIGwgPSBuW29dID0geyBleHBvcnRzOiB7fSB9O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIG4gPSB0W29dWzFdW2VdO3JldHVybiBzKG4gPyBuIDogZSk7XG4gICAgICAgIH0sIGwsIGwuZXhwb3J0cywgZSwgdCwgbiwgcik7XG4gICAgICB9cmV0dXJuIG5bb10uZXhwb3J0cztcbiAgICB9dmFyIGkgPSB0eXBlb2YgcmVxdWlyZSA9PSBcImZ1bmN0aW9uXCIgJiYgcmVxdWlyZTtmb3IgKHZhciBvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspIHtcbiAgICAgIHMocltvXSk7XG4gICAgfXJldHVybiBzO1xuICB9KHsgMTogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgICAgICovXG5cbiAgICAgIHZhciB1cmwgPSBfZGVyZXFfKCcuL3VybCcpO1xuICAgICAgdmFyIHBhcnNlciA9IF9kZXJlcV8oJ3NvY2tldC5pby1wYXJzZXInKTtcbiAgICAgIHZhciBNYW5hZ2VyID0gX2RlcmVxXygnLi9tYW5hZ2VyJyk7XG4gICAgICB2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogTW9kdWxlIGV4cG9ydHMuXG4gICAgICAgKi9cblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4gICAgICAvKipcbiAgICAgICAqIE1hbmFnZXJzIGNhY2hlLlxuICAgICAgICovXG5cbiAgICAgIHZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuICAgICAgLyoqXG4gICAgICAgKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAgICAgICAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gICAgICAgKlxuICAgICAgICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAgICAgICAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gICAgICAgKlxuICAgICAgICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAgICAgICAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuICAgICAgICBpZiAoKHR5cGVvZiB1cmkgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih1cmkpKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG9wdHMgPSB1cmk7XG4gICAgICAgICAgdXJpID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICAgICAgICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgICAgICAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICAgICAgICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICAgICAgICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICAgICAgICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fCBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICAgICAgICB2YXIgaW87XG5cbiAgICAgICAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICAgICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgICAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW8gPSBjYWNoZVtpZF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQcm90b2NvbCB2ZXJzaW9uLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBgY29ubmVjdGAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbiAgICAgIC8qKlxuICAgICAgICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIGV4cG9ydHMuTWFuYWdlciA9IF9kZXJlcV8oJy4vbWFuYWdlcicpO1xuICAgICAgZXhwb3J0cy5Tb2NrZXQgPSBfZGVyZXFfKCcuL3NvY2tldCcpO1xuICAgIH0sIHsgXCIuL21hbmFnZXJcIjogMiwgXCIuL3NvY2tldFwiOiA0LCBcIi4vdXJsXCI6IDUsIFwiZGVidWdcIjogMTQsIFwic29ja2V0LmlvLXBhcnNlclwiOiA0MCB9XSwgMjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgICAgICovXG5cbiAgICAgIHZhciBlaW8gPSBfZGVyZXFfKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG4gICAgICB2YXIgU29ja2V0ID0gX2RlcmVxXygnLi9zb2NrZXQnKTtcbiAgICAgIHZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcbiAgICAgIHZhciBwYXJzZXIgPSBfZGVyZXFfKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG4gICAgICB2YXIgb24gPSBfZGVyZXFfKCcuL29uJyk7XG4gICAgICB2YXIgYmluZCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1iaW5kJyk7XG4gICAgICB2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbiAgICAgIHZhciBpbmRleE9mID0gX2RlcmVxXygnaW5kZXhvZicpO1xuICAgICAgdmFyIEJhY2tvZmYgPSBfZGVyZXFfKCdiYWNrbzInKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBJRTYrIGhhc093blByb3BlcnR5XG4gICAgICAgKi9cblxuICAgICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgICAgIC8qKlxuICAgICAgICogTW9kdWxlIGV4cG9ydHNcbiAgICAgICAqL1xuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbiAgICAgIC8qKlxuICAgICAgICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBNYW5hZ2VyKHVyaSwgb3B0cykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICAgICAgICBpZiAodXJpICYmICdvYmplY3QnID09ICh0eXBlb2YgdXJpID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodXJpKSkpIHtcbiAgICAgICAgICBvcHRzID0gdXJpO1xuICAgICAgICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICAgICAgICB0aGlzLm5zcHMgPSB7fTtcbiAgICAgICAgdGhpcy5zdWJzID0gW107XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICAgICAgICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICAgICAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICAgICAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICAgICAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW5nID0gW107XG4gICAgICAgIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5ldyBwYXJzZXIuRW5jb2RlcigpO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgcGFyc2VyLkRlY29kZXIoKTtcbiAgICAgICAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICAgICAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICAgICAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICAgICAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICAgICAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZW5naW5lLmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBNaXggaW4gYEVtaXR0ZXJgLlxuICAgICAgICovXG5cbiAgICAgIEVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gICAgICAgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gICAgICAgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAgICAgICAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICAgICAgICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBNYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgICAgICAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gICAgICAgIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gICAgICAgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgICAgICAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSB2O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gICAgICAgKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBNYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICAgICAgICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAgICAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAgICAgICAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUub3BlbiA9IE1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgICAgICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgICAgICAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICAgICAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gZW1pdCBgb3BlbmBcbiAgICAgICAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYub25vcGVuKCk7XG4gICAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgICAgICAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgICAgICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgICAgICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICAgICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBmbihlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICAgICAgICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgICAgICAgIC8vIHNldCB0aW1lclxuICAgICAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBNYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdvcGVuJyk7XG5cbiAgICAgICAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgICAgICAgLy8gbWFyayBhcyBvcGVuXG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgICAgICAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBzdWJzXG4gICAgICAgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BpbmcnLCBiaW5kKHRoaXMsICdvbnBpbmcnKSkpO1xuICAgICAgICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBNYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmVtaXRBbGwoJ3BpbmcnKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUub25wb25nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSgpIC0gdGhpcy5sYXN0UGluZyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB3aXRoIGRhdGEuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBNYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICAgICAgICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtTb2NrZXR9XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIE1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uIChuc3ApIHtcbiAgICAgICAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwKTtcbiAgICAgICAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcbiAgICAgICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzb2NrZXQuaWQgPSBzZWxmLmVuZ2luZS5pZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG4gICAgICAgICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldm5ldCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG4gICAgICAgICAgICBvbkNvbm5lY3RpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcoKSB7XG4gICAgICAgICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcbiAgICAgICAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICAgICAgICovXG5cbiAgICAgIE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICAgICAgICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlcyBhIHBhY2tldC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBNYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICAgIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAgICAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgICAgICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuICAgICAgICAgIHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuICAgICAgICogbmV4dCBwYWNrZXQgaW4gbGluZS5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgICAgICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMucGFja2V0KHBhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIE1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG5cbiAgICAgICAgdmFyIHN1YjtcbiAgICAgICAgd2hpbGUgKHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpKSB7XG4gICAgICAgICAgc3ViLmRlc3Ryb3koKTtcbiAgICAgICAgfXRoaXMucGFja2V0QnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIE1hbmFnZXIucHJvdG90eXBlLmNsb3NlID0gTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgICAgICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICAgICAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgZGVidWcoJ29uY2xvc2UnKTtcblxuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICAgICAgICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICAgICAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgICAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGRlbGF5KTtcblxuICAgICAgICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgICAgICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbiAgICAgIH07XG4gICAgfSwgeyBcIi4vb25cIjogMywgXCIuL3NvY2tldFwiOiA0LCBcImJhY2tvMlwiOiA4LCBcImNvbXBvbmVudC1iaW5kXCI6IDExLCBcImNvbXBvbmVudC1lbWl0dGVyXCI6IDEyLCBcImRlYnVnXCI6IDE0LCBcImVuZ2luZS5pby1jbGllbnRcIjogMTYsIFwiaW5kZXhvZlwiOiAzMiwgXCJzb2NrZXQuaW8tcGFyc2VyXCI6IDQwIH1dLCAzOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgICAvKipcbiAgICAgICAqIE1vZHVsZSBleHBvcnRzLlxuICAgICAgICovXG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gb247XG5cbiAgICAgIC8qKlxuICAgICAgICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gb24ob2JqLCBldiwgZm4pIHtcbiAgICAgICAgb2JqLm9uKGV2LCBmbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7fV0sIDQ6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICAgICAqL1xuXG4gICAgICB2YXIgcGFyc2VyID0gX2RlcmVxXygnc29ja2V0LmlvLXBhcnNlcicpO1xuICAgICAgdmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xuICAgICAgdmFyIHRvQXJyYXkgPSBfZGVyZXFfKCd0by1hcnJheScpO1xuICAgICAgdmFyIG9uID0gX2RlcmVxXygnLi9vbicpO1xuICAgICAgdmFyIGJpbmQgPSBfZGVyZXFfKCdjb21wb25lbnQtYmluZCcpO1xuICAgICAgdmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbiAgICAgIHZhciBoYXNCaW4gPSBfZGVyZXFfKCdoYXMtYmluYXJ5Jyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogTW9kdWxlIGV4cG9ydHMuXG4gICAgICAgKi9cblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4gICAgICAvKipcbiAgICAgICAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICAgICAgICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgdmFyIGV2ZW50cyA9IHtcbiAgICAgICAgY29ubmVjdDogMSxcbiAgICAgICAgY29ubmVjdF9lcnJvcjogMSxcbiAgICAgICAgY29ubmVjdF90aW1lb3V0OiAxLFxuICAgICAgICBjb25uZWN0aW5nOiAxLFxuICAgICAgICBkaXNjb25uZWN0OiAxLFxuICAgICAgICBlcnJvcjogMSxcbiAgICAgICAgcmVjb25uZWN0OiAxLFxuICAgICAgICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgICAgICAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgICAgICAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICAgICAgICByZWNvbm5lY3Rpbmc6IDEsXG4gICAgICAgIHBpbmc6IDEsXG4gICAgICAgIHBvbmc6IDFcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gICAgICAgKi9cblxuICAgICAgdmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4gICAgICAvKipcbiAgICAgICAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gU29ja2V0KGlvLCBuc3ApIHtcbiAgICAgICAgdGhpcy5pbyA9IGlvO1xuICAgICAgICB0aGlzLm5zcCA9IG5zcDtcbiAgICAgICAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gICAgICAgIHRoaXMuaWRzID0gMDtcbiAgICAgICAgdGhpcy5hY2tzID0ge307XG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWl4IGluIGBFbWl0dGVyYC5cbiAgICAgICAqL1xuXG4gICAgICBFbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIFNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGlvID0gdGhpcy5pbztcbiAgICAgICAgdGhpcy5zdWJzID0gW29uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSwgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSwgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSldO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIFNvY2tldC5wcm90b3R5cGUub3BlbiA9IFNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLnN1YkV2ZW50cygpO1xuICAgICAgICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgICAgICAgaWYgKCdvcGVuJyA9PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIFNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZSBgZW1pdGAuXG4gICAgICAgKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICAgICAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIFNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgICAgICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcGFyc2VyVHlwZSA9IHBhcnNlci5FVkVOVDsgLy8gZGVmYXVsdFxuICAgICAgICBpZiAoaGFzQmluKGFyZ3MpKSB7XG4gICAgICAgICAgcGFyc2VyVHlwZSA9IHBhcnNlci5CSU5BUllfRVZFTlQ7XG4gICAgICAgIH0gLy8gYmluYXJ5XG4gICAgICAgIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuICAgICAgICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICAgICAgICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gICAgICAgIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICAgICAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICAgICAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFNlbmRzIGEgcGFja2V0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIFNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gICAgICAgIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAgICAgICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCcvJyAhPSB0aGlzLm5zcCkge1xuICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkNPTk5FQ1QgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWQ7XG4gICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgICAgaWYgKHBhY2tldC5uc3AgIT0gdGhpcy5uc3ApIHJldHVybjtcblxuICAgICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgICAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICAgICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBTb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICAgIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gICAgICAgIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gICAgICAgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgICAgICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgICAgICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIFNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICAgICAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgICAgICAgIHNlbnQgPSB0cnVlO1xuICAgICAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgICAgICAgdmFyIHR5cGUgPSBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0s7XG4gICAgICAgICAgc2VsZi5wYWNrZXQoe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGRhdGE6IGFyZ3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgICAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYWNrKSB7XG4gICAgICAgICAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gICAgICAgIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBTb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gICAgICAgKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICAgICAgICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlLlxuICAgICAgICovXG5cbiAgICAgIFNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicykge1xuICAgICAgICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN1YnMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgICAgICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBTb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICAgICAgICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi9vblwiOiAzLCBcImNvbXBvbmVudC1iaW5kXCI6IDExLCBcImNvbXBvbmVudC1lbWl0dGVyXCI6IDEyLCBcImRlYnVnXCI6IDE0LCBcImhhcy1iaW5hcnlcIjogMzAsIFwic29ja2V0LmlvLXBhcnNlclwiOiA0MCwgXCJ0by1hcnJheVwiOiA0MyB9XSwgNTogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBwYXJzZXVyaSA9IF9kZXJlcV8oJ3BhcnNldXJpJyk7XG4gICAgICAgIHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZHVsZSBleHBvcnRzLlxuICAgICAgICAgKi9cblxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVVJMIHBhcnNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAgICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgICovXG5cbiAgICAgICAgZnVuY3Rpb24gdXJsKHVyaSwgbG9jKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHVyaTtcblxuICAgICAgICAgIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gICAgICAgICAgdmFyIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gICAgICAgICAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgICAgICAgICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgICAgICAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHVyaSkge1xuICAgICAgICAgICAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICAgICAgICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgICAgICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGxvYykge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwYXJzZVxuICAgICAgICAgICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICAgICAgICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gICAgICAgICAgaWYgKCFvYmoucG9ydCkge1xuICAgICAgICAgICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgICAgICAgICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gICAgICAgICAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAgICAgICAgIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgICAgICAgICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgICAgICAgICAvLyBkZWZpbmUgaHJlZlxuICAgICAgICAgIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PSBvYmoucG9ydCA/ICcnIDogJzonICsgb2JqLnBvcnQpO1xuXG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbiAgICB9LCB7IFwiZGVidWdcIjogMTQsIFwicGFyc2V1cmlcIjogMzggfV0sIDY6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGFmdGVyO1xuXG4gICAgICBmdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgICAgICB2YXIgYmFpbCA9IGZhbHNlO1xuICAgICAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcDtcbiAgICAgICAgcHJveHkuY291bnQgPSBjb3VudDtcblxuICAgICAgICByZXR1cm4gY291bnQgPT09IDAgPyBjYWxsYmFjaygpIDogcHJveHk7XG5cbiAgICAgICAgZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLS1wcm94eS5jb3VudDtcblxuICAgICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgYmFpbCA9IHRydWU7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIH0sIHt9XSwgNzogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIC8qKlxuICAgICAgICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gICAgICAgKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgICAgICAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgIHN0YXJ0ICs9IGJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgZW5kICs9IGJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiBieXRlcykge1xuICAgICAgICAgIGVuZCA9IGJ5dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgICAgICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbiAgICAgIH07XG4gICAgfSwge31dLCA4OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgICAvKipcbiAgICAgICAqIEV4cG9zZSBgQmFja29mZmAuXG4gICAgICAgKi9cblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4gICAgICAvKipcbiAgICAgICAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAgICAgICAqXG4gICAgICAgKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAgICAgICAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICAgICAgICogLSBgaml0dGVyYCBbMF1cbiAgICAgICAqIC0gYGZhY3RvcmAgWzJdXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICAgICAgICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICAgICAgICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gICAgICAgIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gICAgICAgIHRoaXMuYXR0ZW1wdHMgPSAwO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIEJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gICAgICAgIGlmICh0aGlzLmppdHRlcikge1xuICAgICAgICAgIHZhciByYW5kID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgICAgICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXR0ZW1wdHMgPSAwO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIEJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uIChtaW4pIHtcbiAgICAgICAgdGhpcy5tcyA9IG1pbjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBCYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbiAobWF4KSB7XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIGppdHRlclxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24gKGppdHRlcikge1xuICAgICAgICB0aGlzLmppdHRlciA9IGppdHRlcjtcbiAgICAgIH07XG4gICAgfSwge31dLCA5OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgLypcbiAgICAgICAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICAgICAgICpcbiAgICAgICAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAgICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICAgICAqL1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbiAgICAgICAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICAgICAgICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChhcnJheWJ1ZmZlcikge1xuICAgICAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgbGVuID0gYnl0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICBiYXNlNjQgPSBcIlwiO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgICAgICBiYXNlNjQgKz0gY2hhcnNbKGJ5dGVzW2ldICYgMykgPDwgNCB8IGJ5dGVzW2kgKyAxXSA+PiA0XTtcbiAgICAgICAgICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpICsgMl0gPj4gNl07XG4gICAgICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgICAgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICAgICAgfTtcblxuICAgICAgICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChiYXNlNjQpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgICAgICAgICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIHAgPSAwLFxuICAgICAgICAgICAgICBlbmNvZGVkMSxcbiAgICAgICAgICAgICAgZW5jb2RlZDIsXG4gICAgICAgICAgICAgIGVuY29kZWQzLFxuICAgICAgICAgICAgICBlbmNvZGVkNDtcblxuICAgICAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgICAgICAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICAgICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDIpXTtcbiAgICAgICAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG5cbiAgICAgICAgICAgIGJ5dGVzW3ArK10gPSBlbmNvZGVkMSA8PCAyIHwgZW5jb2RlZDIgPj4gNDtcbiAgICAgICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDIgJiAxNSkgPDwgNCB8IGVuY29kZWQzID4+IDI7XG4gICAgICAgICAgICBieXRlc1twKytdID0gKGVuY29kZWQzICYgMykgPDwgNiB8IGVuY29kZWQ0ICYgNjM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcbiAgICB9LCB7fV0sIDEwOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBCbG9iQnVpbGRlciA9IGdsb2JhbC5CbG9iQnVpbGRlciB8fCBnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgZ2xvYmFsLk1TQmxvYkJ1aWxkZXIgfHwgZ2xvYmFsLk1vekJsb2JCdWlsZGVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgYmxvYlN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGEgPSBuZXcgQmxvYihbJ2hpJ10pO1xuICAgICAgICAgICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICAgICAgICAgKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLCAyXSldKTtcbiAgICAgICAgICAgIHJldHVybiBiLnNpemUgPT09IDI7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBCbG9iQnVpbGRlciBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXIgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZCAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICAgICAgICAgKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAgICAgICAgICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICovXG5cbiAgICAgICAgZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgICAgICAgICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XG5cbiAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAgICAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgICAgICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCAhPT0gYnVmLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGJ1ZiA9IGNvcHkuYnVmZmVyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYXJ5W2ldID0gYnVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICAgICAgICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMudHlwZSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuICAgICAgICAgIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB9O1xuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gICAgICAgICAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KCk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xuICAgIH0sIHt9XSwgMTE6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAvKipcbiAgICAgICAqIFNsaWNlIHJlZmVyZW5jZS5cbiAgICAgICAqL1xuXG4gICAgICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgZm4pIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0sIHt9XSwgMTI6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRXhwb3NlIGBFbWl0dGVyYC5cbiAgICAgICAqL1xuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbiAgICAgIC8qKlxuICAgICAgICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICAgICAgICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICAgICAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICAgICAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgICAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBvbi5mbiA9IGZuO1xuICAgICAgICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICAgICAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAgICogQHJldHVybiB7RW1pdHRlcn1cbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgRW1pdHRlci5wcm90b3R5cGUub2ZmID0gRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgICAgICAgLy8gYWxsXG4gICAgICAgIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAgICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICAgICAgICB2YXIgY2I7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gICAgICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxuICAgICAgICovXG5cbiAgICAgIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIEVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xuICAgICAgfTtcbiAgICB9LCB7fV0sIDEzOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIGZuKCkge307XG4gICAgICAgIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgICAgICBhLnByb3RvdHlwZSA9IG5ldyBmbigpO1xuICAgICAgICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG4gICAgICB9O1xuICAgIH0sIHt9XSwgMTQ6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICAgICAgICpcbiAgICAgICAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2RlYnVnJyk7XG4gICAgICBleHBvcnRzLmxvZyA9IGxvZztcbiAgICAgIGV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgICBleHBvcnRzLnNhdmUgPSBzYXZlO1xuICAgICAgZXhwb3J0cy5sb2FkID0gbG9hZDtcbiAgICAgIGV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuICAgICAgZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZSAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2UgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbCA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbG9ycy5cbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLmNvbG9ycyA9IFsnbGlnaHRzZWFncmVlbicsICdmb3Jlc3RncmVlbicsICdnb2xkZW5yb2QnLCAnZG9kZ2VyYmx1ZScsICdkYXJrb3JjaGlkJywgJ2NyaW1zb24nXTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICAgICAgICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gICAgICAgKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gICAgICAgKlxuICAgICAgICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gICAgICAgIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gICAgICAgIHJldHVybiAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlIHx8XG4gICAgICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCBjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSB8fFxuICAgICAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICAgICAgICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgKyBhcmdzWzBdICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICAgICAgICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgICAgICAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICAgICAgICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgICAgICAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgICAgICAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGxhc3RDID0gMDtcbiAgICAgICAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAgICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgICAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICAgICAgICBsYXN0QyA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBsb2coKSB7XG4gICAgICAgIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gICAgICAgIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gICAgICAgIHJldHVybiAnb2JqZWN0JyA9PT0gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpICYmIGNvbnNvbGUubG9nICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4gICAgICAvKipcbiAgICAgICAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAgICAgICAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gICAgICAgKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9LCB7IFwiLi9kZWJ1Z1wiOiAxNSB9XSwgMTU6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICAgICAgICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAgICAgICAqXG4gICAgICAgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gICAgICAgKi9cblxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG4gICAgICBleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbiAgICAgIGV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG4gICAgICBleHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbiAgICAgIGV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICBleHBvcnRzLmh1bWFuaXplID0gX2RlcmVxXygnbXMnKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLm5hbWVzID0gW107XG4gICAgICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAgICAgICpcbiAgICAgICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICAgICAgICovXG5cbiAgICAgIGV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gICAgICAgKi9cblxuICAgICAgdmFyIHByZXZDb2xvciA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAgICAgICAqL1xuXG4gICAgICB2YXIgcHJldlRpbWU7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IGEgY29sb3IuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAgICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gICAgICAgIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gICAgICAgIGZ1bmN0aW9uIGRpc2FibGVkKCkge31cbiAgICAgICAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgICAgICAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgICAgICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgICAgICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgICAgICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgICAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICAgICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgICAgICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICAgICAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgICAgICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgICAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICAgICAgICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAgICAgICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICAgICAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gICAgICAgIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgICAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICBleHBvcnRzLmVuYWJsZSgnJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICAgICAgdmFyIGksIGxlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29lcmNlIGB2YWxgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgICAgICogQHJldHVybiB7TWl4ZWR9XG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9LCB7IFwibXNcIjogMzUgfV0sIDE2OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vbGliLycpO1xuICAgIH0sIHsgXCIuL2xpYi9cIjogMTcgfV0sIDE3OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vc29ja2V0Jyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogRXhwb3J0cyBwYXJzZXJcbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgbW9kdWxlLmV4cG9ydHMucGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xuICAgIH0sIHsgXCIuL3NvY2tldFwiOiAxOCwgXCJlbmdpbmUuaW8tcGFyc2VyXCI6IDI3IH1dLCAxODogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgdHJhbnNwb3J0cyA9IF9kZXJlcV8oJy4vdHJhbnNwb3J0cycpO1xuICAgICAgICB2YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG4gICAgICAgIHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG4gICAgICAgIHZhciBpbmRleCA9IF9kZXJlcV8oJ2luZGV4b2YnKTtcbiAgICAgICAgdmFyIHBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcbiAgICAgICAgdmFyIHBhcnNldXJpID0gX2RlcmVxXygncGFyc2V1cmknKTtcbiAgICAgICAgdmFyIHBhcnNlanNvbiA9IF9kZXJlcV8oJ3BhcnNlanNvbicpO1xuICAgICAgICB2YXIgcGFyc2VxcyA9IF9kZXJlcV8oJ3BhcnNlcXMnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kdWxlIGV4cG9ydHMuXG4gICAgICAgICAqL1xuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb29wIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBmdW5jdGlvbiBTb2NrZXQodXJpLCBvcHRzKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAgIGlmICh1cmkgJiYgJ29iamVjdCcgPT0gKHR5cGVvZiB1cmkgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih1cmkpKSkge1xuICAgICAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgICAgIHVyaSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVyaSkge1xuICAgICAgICAgICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICAgICAgICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuICAgICAgICAgICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgICAgICAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgICAgICAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDogZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuXG4gICAgICAgICAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgICAgICAgICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgICAgICAgICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHwgKGdsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICAgICAgICAgIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnQgPyBsb2NhdGlvbi5wb3J0IDogdGhpcy5zZWN1cmUgPyA0NDMgOiA4MCk7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gICAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gICAgICAgICAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgICAgICAgICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgICAgICAgICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgICAgICAgICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gICAgICAgICAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgICAgICAgICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgICAgICAgICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gICAgICAgICAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gICAgICAgICAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgICAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgICAgICAgICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICAgICAgICAgIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgICAgICAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9IDogZmFsc2U7XG5cbiAgICAgICAgICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgICAgICAgIGlmICh0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmIG51bGwgPT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgICAgICAgICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gICAgICAgICAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICAgICAgICAgIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICAgICAgICAgIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICAgICAgICAgIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gICAgICAgICAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gICAgICAgICAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gICAgICAgICAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgICAgICAgICB2YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZ2xvYmFsKSkgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICAgICAgICAgIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgICAgICAgICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1peCBpbiBgRW1pdHRlcmAuXG4gICAgICAgICAqL1xuXG4gICAgICAgIEVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3RvY29sIHZlcnNpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgICAqL1xuXG4gICAgICAgIFNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gICAgICAgICAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICAgICAgICAgKi9cblxuICAgICAgICBTb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuICAgICAgICBTb2NrZXQuVHJhbnNwb3J0ID0gX2RlcmVxXygnLi90cmFuc3BvcnQnKTtcbiAgICAgICAgU29ja2V0LnRyYW5zcG9ydHMgPSBfZGVyZXFfKCcuL3RyYW5zcG9ydHMnKTtcbiAgICAgICAgU29ja2V0LnBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBTb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgICAgICAgICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAgICAgICAgIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICAgICAgICAgIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAgICAgICAgIC8vIHRyYW5zcG9ydCBuYW1lXG4gICAgICAgICAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAgICAgICAgIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICAgICAgICAgIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gICAgICAgICAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICAgICAgICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgICAgICAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgICAgICAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgZm9yY2VKU09OUDogdGhpcy5mb3JjZUpTT05QLFxuICAgICAgICAgICAganNvbnA6IHRoaXMuanNvbnAsXG4gICAgICAgICAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICAgICAgICAgIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUixcbiAgICAgICAgICAgIHRpbWVzdGFtcFJlcXVlc3RzOiB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgICAgICAgICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgICAgICAgICBwb2xpY3lQb3J0OiB0aGlzLnBvbGljeVBvcnQsXG4gICAgICAgICAgICBzb2NrZXQ6IHRoaXMsXG4gICAgICAgICAgICBwZng6IHRoaXMucGZ4LFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIHBhc3NwaHJhc2U6IHRoaXMucGFzc3BocmFzZSxcbiAgICAgICAgICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICAgICAgICAgIGNhOiB0aGlzLmNhLFxuICAgICAgICAgICAgY2lwaGVyczogdGhpcy5jaXBoZXJzLFxuICAgICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVyc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICAgICAgICB2YXIgbyA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBTb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRyYW5zcG9ydDtcbiAgICAgICAgICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT0gLTEpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gICAgICAgICAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgICAgICAgICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAgICAgICAgIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gICAgICAgICAgdHJhbnNwb3J0Lm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25EcmFpbigpO1xuICAgICAgICAgIH0pLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICAgICAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gICAgICAgICAgfSkub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICAgICAgICB9KS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pLFxuICAgICAgICAgICAgICBmYWlsZWQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgICAgICAgICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgICAgICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgICAgICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgICAgICAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgICAgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgICAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgICAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICAgICAgICAgIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICAgICAgICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgICAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgICAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpIHtcbiAgICAgICAgICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gICAgICAgICAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICAgICAgICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgICAgICAgICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pIHtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgICAgICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICAgICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICAgICAgICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgICAgICAgICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICAgICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgICAgICAgICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgICAgICAgICB0cmFuc3BvcnQub3BlbigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBTb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gICAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gICAgICAgICAgdGhpcy5mbHVzaCgpO1xuXG4gICAgICAgICAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAgICAgICAgIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgICAgICAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICAgICAgICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBhIHBhY2tldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICAgICAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAgICAgICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BvbmcnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgICAgICAgICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gICAgICAgICAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gICAgICAgICAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gICAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgICAgICAgIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG5cbiAgICAgICAgICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgICAgICAgICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gICAgICAgICAgfSwgdGltZW91dCB8fCBzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICAgICAgICAgKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgICAgICAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgc2VsZi5waW5nKCk7XG4gICAgICAgICAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICAgICAgICAgIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuICAgICAgICAqXG4gICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICovXG5cbiAgICAgICAgU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gICAgICAgICAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAgICAgICAgIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAgICAgICAgIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gICAgICAgICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICAgICAgICAgIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAgICAgICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgICAgICAgICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kcyBhIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gICAgICAgICAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBTb2NrZXQucHJvdG90eXBlLndyaXRlID0gU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYSBwYWNrZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBvcHRpb25zLCBmbikge1xuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSB7XG4gICAgICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBmbiA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgICAgICAgICB2YXIgcGFja2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gICAgICAgICAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICAgICAgICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgICAgICAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSgpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG4gICAgICAgICAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgICAgICAgICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBTb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gICAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICAgICAgICAgIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgLy8gY2xlYXIgdGltZXJzXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgICAgICAgICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgICAgICAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICAgICAgICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgICAgICAgICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgICAgICAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICAgICAgICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgICAgICBTb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gICAgICAgICAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG4gICAgICAgIH07XG4gICAgICB9KS5jYWxsKHRoaXMsIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xuICAgIH0sIHsgXCIuL3RyYW5zcG9ydFwiOiAxOSwgXCIuL3RyYW5zcG9ydHNcIjogMjAsIFwiY29tcG9uZW50LWVtaXR0ZXJcIjogMjYsIFwiZGVidWdcIjogMTQsIFwiZW5naW5lLmlvLXBhcnNlclwiOiAyNywgXCJpbmRleG9mXCI6IDMyLCBcInBhcnNlanNvblwiOiAzNiwgXCJwYXJzZXFzXCI6IDM3LCBcInBhcnNldXJpXCI6IDM4IH1dLCAxOTogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIC8qKlxuICAgICAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICAgICAqL1xuXG4gICAgICB2YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xuICAgICAgdmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE1vZHVsZSBleHBvcnRzLlxuICAgICAgICovXG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIFRyYW5zcG9ydChvcHRzKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gICAgICAgIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgICAgICAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gICAgICAgIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gICAgICAgIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICAgICAgICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgICAgICAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gICAgICAgIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gICAgICAgIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gICAgICAgIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgICAgICAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICAgICAgICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgICAgICAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICAgICAgICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gICAgICAgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gICAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWl4IGluIGBFbWl0dGVyYC5cbiAgICAgICAqL1xuXG4gICAgICBFbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEVtaXRzIGFuIGVycm9yLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICAgICAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gICAgICAgIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgICAgICAgdGhpcy5kb09wZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICAgICAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdXBvbiBvcGVuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgd2l0aCBkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICAgICAgICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gICAgICAgKi9cblxuICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICB9O1xuICAgIH0sIHsgXCJjb21wb25lbnQtZW1pdHRlclwiOiAyNiwgXCJlbmdpbmUuaW8tcGFyc2VyXCI6IDI3IH1dLCAyMDogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBYTUxIdHRwUmVxdWVzdCA9IF9kZXJlcV8oJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICAgICAgICB2YXIgWEhSID0gX2RlcmVxXygnLi9wb2xsaW5nLXhocicpO1xuICAgICAgICB2YXIgSlNPTlAgPSBfZGVyZXFfKCcuL3BvbGxpbmctanNvbnAnKTtcbiAgICAgICAgdmFyIHdlYnNvY2tldCA9IF9kZXJlcV8oJy4vd2Vic29ja2V0Jyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICAgICAgICAgKi9cblxuICAgICAgICBleHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuICAgICAgICBleHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gICAgICAgICAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgZnVuY3Rpb24gcG9sbGluZyhvcHRzKSB7XG4gICAgICAgICAgdmFyIHhocjtcbiAgICAgICAgICB2YXIgeGQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgeHMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICAgICAgICAgIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICAgICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgICAgICAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgICAgICAgICBpZiAoIXBvcnQpIHtcbiAgICAgICAgICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICAgICAgICAgIHhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3B0cy54ZG9tYWluID0geGQ7XG4gICAgICAgICAgb3B0cy54c2NoZW1lID0geHM7XG4gICAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gICAgICAgICAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYSFIob3B0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KS5jYWxsKHRoaXMsIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xuICAgIH0sIHsgXCIuL3BvbGxpbmctanNvbnBcIjogMjEsIFwiLi9wb2xsaW5nLXhoclwiOiAyMiwgXCIuL3dlYnNvY2tldFwiOiAyNCwgXCJ4bWxodHRwcmVxdWVzdC1zc2xcIjogMjUgfV0sIDIxOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIFBvbGxpbmcgPSBfZGVyZXFfKCcuL3BvbGxpbmcnKTtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBfZGVyZXFfKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2R1bGUgZXhwb3J0cy5cbiAgICAgICAgICovXG5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgck5ld2xpbmUgPSAvXFxuL2c7XG4gICAgICAgIHZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGNhbGxiYWNrcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2tzIGNvdW50LlxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb29wLlxuICAgICAgICAgKi9cblxuICAgICAgICBmdW5jdGlvbiBlbXB0eSgpIHt9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBmdW5jdGlvbiBKU09OUFBvbGxpbmcob3B0cykge1xuICAgICAgICAgIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gICAgICAgICAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICAgICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgICAgICAgICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgICAgICAgICBjYWxsYmFja3MgPSBnbG9iYWwuX19fZWlvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgICAgICAgICB0aGlzLmluZGV4ID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAgICAgICAgIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGFwcGVuZCB0byBxdWVyeSBzdHJpbmdcbiAgICAgICAgICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gICAgICAgICAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICAgICAgICAgIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gICAgICAgICAqL1xuXG4gICAgICAgIEpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5mb3JtKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgICAgICAgICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsIGUpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gICAgICAgICAgaWYgKGluc2VydEF0KSB7XG4gICAgICAgICAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgICAgICAgICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gICAgICAgICAgaWYgKGlzVUFnZWNrbykge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgICAgICAgICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdmFyIGlmcmFtZTtcblxuICAgICAgICAgICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgICAgICAgICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICAgICAgICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICAgICAgICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgICAgICAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgICAgICAgICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICAgICAgICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgICAgICAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgICAgICBpbml0SWZyYW1lKCk7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGluaXRJZnJhbWUoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICAgICAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicgKyBzZWxmLmlmcmFtZUlkICsgJ1wiPic7XG4gICAgICAgICAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICAgICAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgICAgICAgICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0SWZyYW1lKCk7XG5cbiAgICAgICAgICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgICAgICAgICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gICAgICAgICAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICAgIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbiAgICB9LCB7IFwiLi9wb2xsaW5nXCI6IDIzLCBcImNvbXBvbmVudC1pbmhlcml0XCI6IDEzIH1dLCAyMjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgWE1MSHR0cFJlcXVlc3QgPSBfZGVyZXFfKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgICAgICAgdmFyIFBvbGxpbmcgPSBfZGVyZXFfKCcuL3BvbGxpbmcnKTtcbiAgICAgICAgdmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xuICAgICAgICB2YXIgaW5oZXJpdCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG4gICAgICAgIHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kdWxlIGV4cG9ydHMuXG4gICAgICAgICAqL1xuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gWEhSO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW1wdHkgZnVuY3Rpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgICovXG5cbiAgICAgICAgZnVuY3Rpb24gWEhSKG9wdHMpIHtcbiAgICAgICAgICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgICAgICAgICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgICAgICAgICAgaWYgKCFwb3J0KSB7XG4gICAgICAgICAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPSBnbG9iYWwubG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgICAgICAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAgICAgICAgICovXG5cbiAgICAgICAgaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gICAgICAgICAqL1xuXG4gICAgICAgIFhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gICAgICAgICAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gICAgICAgICAgb3B0cy54cyA9IHRoaXMueHM7XG4gICAgICAgICAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gICAgICAgICAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gICAgICAgICAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG4gICAgICAgICAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gICAgICAgICAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgICAgICAgICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICAgICAgICAgIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgICAgICAgICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gICAgICAgICAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gICAgICAgICAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICAgICAgICAgIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgICAgICAgICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICAgICAgICAgIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmRzIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gICAgICAgICAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICAgICAgICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnNlbmRYaHIgPSByZXE7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBYSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgICAgICAgICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wb2xsWGhyID0gcmVxO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgICAqL1xuXG4gICAgICAgIGZ1bmN0aW9uIFJlcXVlc3Qob3B0cykge1xuICAgICAgICAgIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gICAgICAgICAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgICAgICAgICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICAgICAgICAgIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gICAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICAgICAgICAgIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICAgICAgICAgIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuICAgICAgICAgIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICAgICAgICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICAgICAgICAgIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAgICAgICAgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICAgICAgICAgIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gICAgICAgICAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgICAgICAgICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gICAgICAgICAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICAgICAgICAgIHRoaXMuY2EgPSBvcHRzLmNhO1xuICAgICAgICAgIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgICAgICAgICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gICAgICAgICAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgICAgICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gICAgICAgICAgdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaXggaW4gYEVtaXR0ZXJgLlxuICAgICAgICAgKi9cblxuICAgICAgICBFbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50LCB4ZG9tYWluOiB0aGlzLnhkLCB4c2NoZW1lOiB0aGlzLnhzLCBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIgfTtcblxuICAgICAgICAgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICAgICAgICAgIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gICAgICAgICAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgICAgICAgICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gICAgICAgICAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICAgICAgICAgIG9wdHMuY2EgPSB0aGlzLmNhO1xuICAgICAgICAgIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgICAgICAgICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gICAgICAgICAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWJ1ZygneGhyIG9wZW4gJXM6ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcbiAgICAgICAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJ1BPU1QnID09IHRoaXMubWV0aG9kKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZTYgY2hlY2tcbiAgICAgICAgICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICAgICAgICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgICAgICAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICAgICAgICAgIHRoaXMub25TdWNjZXNzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB1cG9uIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICB0aGlzLmNsZWFudXAodHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFucyB1cCBob3VzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoZnJvbUVycm9yKSB7XG4gICAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB4bWxodHRwcmVxdWVzdFxuICAgICAgICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICAgICAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmcm9tRXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMueGhyID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHVwb24gbG9hZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHVpOEFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IHVpOEFyci5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUFycmF5LnB1c2godWk4QXJyW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhQXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICAgICAgICAgKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gICAgICAgICAqIGVtaXR0ZWQuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgICAgICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuICAgICAgICAgIFJlcXVlc3QucmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgICAgICAgICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbiAgICB9LCB7IFwiLi9wb2xsaW5nXCI6IDIzLCBcImNvbXBvbmVudC1lbWl0dGVyXCI6IDI2LCBcImNvbXBvbmVudC1pbmhlcml0XCI6IDEzLCBcImRlYnVnXCI6IDE0LCBcInhtbGh0dHByZXF1ZXN0LXNzbFwiOiAyNSB9XSwgMjM6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAvKipcbiAgICAgICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAgICAgKi9cblxuICAgICAgdmFyIFRyYW5zcG9ydCA9IF9kZXJlcV8oJy4uL3RyYW5zcG9ydCcpO1xuICAgICAgdmFyIHBhcnNlcXMgPSBfZGVyZXFfKCdwYXJzZXFzJyk7XG4gICAgICB2YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xuICAgICAgdmFyIGluaGVyaXQgPSBfZGVyZXFfKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuICAgICAgdmFyIHllYXN0ID0gX2RlcmVxXygneWVhc3QnKTtcbiAgICAgIHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE1vZHVsZSBleHBvcnRzLlxuICAgICAgICovXG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAgICAgICAqL1xuXG4gICAgICB2YXIgaGFzWEhSMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gX2RlcmVxXygneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0oKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBQb2xsaW5nIGludGVyZmFjZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gUG9sbGluZyhvcHRzKSB7XG4gICAgICAgIHZhciBmb3JjZUJhc2U2NCA9IG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NDtcbiAgICAgICAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgICAgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICAgICAgICovXG5cbiAgICAgIGluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc3BvcnQgbmFtZS5cbiAgICAgICAqL1xuXG4gICAgICBQb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAgICAgICAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIFBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFBhdXNlcyBwb2xsaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuICAgICAgICB2YXIgcGVuZGluZyA9IDA7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgICAgICAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgICAgZGVidWcoJ3BhdXNlZCcpO1xuICAgICAgICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuICAgICAgICAgIG9uUGF1c2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBQb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncG9sbGluZycpO1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmRvUG9sbCgpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BvbGwnKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgUG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgICAgICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICAgICAgICBpZiAoJ29wZW5pbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgICAgICAgaWYgKCdjbG9zZScgPT0gcGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICAgICAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZGVjb2RlIHBheWxvYWRcbiAgICAgICAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gICAgICAgIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gICAgICAgIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgICAgICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICAgICAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICAgICAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgICAgICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgICAgICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgICAgICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbiBjYWxsYmFja2ZuKCkge1xuICAgICAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBQb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gICAgICAgIHZhciBwb3J0ID0gJyc7XG5cbiAgICAgICAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgICAgICAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgICAgICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICAgICAgICBxdWVyeS5iNjQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgICAgICAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgICAgICAgaWYgKHRoaXMucG9ydCAmJiAoJ2h0dHBzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MyB8fCAnaHR0cCcgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpIHtcbiAgICAgICAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gICAgICAgIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gICAgICAgIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xuICAgICAgfTtcbiAgICB9LCB7IFwiLi4vdHJhbnNwb3J0XCI6IDE5LCBcImNvbXBvbmVudC1pbmhlcml0XCI6IDEzLCBcImRlYnVnXCI6IDE0LCBcImVuZ2luZS5pby1wYXJzZXJcIjogMjcsIFwicGFyc2Vxc1wiOiAzNywgXCJ4bWxodHRwcmVxdWVzdC1zc2xcIjogMjUsIFwieWVhc3RcIjogNDUgfV0sIDI0OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBUcmFuc3BvcnQgPSBfZGVyZXFfKCcuLi90cmFuc3BvcnQnKTtcbiAgICAgICAgdmFyIHBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcbiAgICAgICAgdmFyIHBhcnNlcXMgPSBfZGVyZXFfKCdwYXJzZXFzJyk7XG4gICAgICAgIHZhciBpbmhlcml0ID0gX2RlcmVxXygnY29tcG9uZW50LWluaGVyaXQnKTtcbiAgICAgICAgdmFyIHllYXN0ID0gX2RlcmVxXygneWVhc3QnKTtcbiAgICAgICAgdmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcbiAgICAgICAgdmFyIEJyb3dzZXJXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAgICAgICAgICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAgICAgICAgICogaW50ZXJmYWNlIGV4cG9zZWQgYnkgYHdzYCBmb3IgTm9kZS1saWtlIGVudmlyb25tZW50LlxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbiAgICAgICAgaWYgKCFXZWJTb2NrZXQgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgV2ViU29ja2V0ID0gX2RlcmVxXygnd3MnKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZHVsZSBleHBvcnRzLlxuICAgICAgICAgKi9cblxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBmdW5jdGlvbiBXUyhvcHRzKSB7XG4gICAgICAgICAgdmFyIGZvcmNlQmFzZTY0ID0gb3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0O1xuICAgICAgICAgIGlmIChmb3JjZUJhc2U2NCkge1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAgICAgICAgICovXG5cbiAgICAgICAgaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNwb3J0IG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgICAqL1xuXG4gICAgICAgIFdTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICAgICAgICAgKi9cblxuICAgICAgICBXUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVucyBzb2NrZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBXUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgICAgICAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgICAgICAgICB2YXIgcHJvdG9jb2xzID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgICAgICAgICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICAgICAgICAgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gICAgICAgICAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICAgICAgICAgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgICAgICAgICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgICAgICAgICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gICAgICAgICAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMud3MgPSBCcm93c2VyV2ViU29ja2V0ID8gbmV3IFdlYlNvY2tldCh1cmkpIDogbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG5cbiAgICAgICAgICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYnVmZmVyJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFdTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIGBvbkRhdGFgIHRvIHVzZSBhIHRpbWVyIG9uIGlPUy5cbiAgICAgICAgICogU2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tbG91Z2hyYW4vMjA1MjAwNlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgV1MucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLCBkYXRhKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgICAgICAgICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gICAgICAgICAgdmFyIHRvdGFsID0gcGFja2V0cy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1NvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgICAgICAgICAvL2hhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAgICAgICAgIC8vdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKEJyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkocGFja2V0c1tpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZmx1c2gnKTtcblxuICAgICAgICAgICAgLy8gZmFrZSBkcmFpblxuICAgICAgICAgICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB1cG9uIGNsb3NlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBXUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHNvY2tldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFdTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBXUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gICAgICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICAgICAgICAgIHZhciBwb3J0ID0gJyc7XG5cbiAgICAgICAgICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICAgICAgICAgIGlmICh0aGlzLnBvcnQgJiYgKCd3c3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzIHx8ICd3cycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpIHtcbiAgICAgICAgICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgICAgICAgICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgICAgICAgICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgcXVlcnkuYjY0ID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAgICAgICAgIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICAgICAgICAgIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gICAgICAgICAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBXUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xuICAgICAgICB9O1xuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbiAgICB9LCB7IFwiLi4vdHJhbnNwb3J0XCI6IDE5LCBcImNvbXBvbmVudC1pbmhlcml0XCI6IDEzLCBcImRlYnVnXCI6IDE0LCBcImVuZ2luZS5pby1wYXJzZXJcIjogMjcsIFwicGFyc2Vxc1wiOiAzNywgXCJ3c1wiOiB1bmRlZmluZWQsIFwieWVhc3RcIjogNDUgfV0sIDI1OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcbiAgICAgIHZhciBoYXNDT1JTID0gX2RlcmVxXygnaGFzLWNvcnMnKTtcblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAgICAgICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgICAgICAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICAgICAgICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgICAgICAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgICAgICAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gICAgICAgIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICBpZiAoIXhkb21haW4pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgeyBcImhhcy1jb3JzXCI6IDMxIH1dLCAyNjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICAgICAgICovXG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuICAgICAgLyoqXG4gICAgICAgKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gICAgICAgIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIG1peGluKG9iaikge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gICAgICAgKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uLmZuID0gZm47XG4gICAgICAgIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gICAgICAgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAgICAgICAvLyBhbGxcbiAgICAgICAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgICAgIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICAgIHZhciBjYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge01peGVkfSAuLi5cbiAgICAgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAgICAgKi9cblxuICAgICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG4gICAgICB9O1xuICAgIH0sIHt9XSwgMjc6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGtleXMgPSBfZGVyZXFfKCcuL2tleXMnKTtcbiAgICAgICAgdmFyIGhhc0JpbmFyeSA9IF9kZXJlcV8oJ2hhcy1iaW5hcnknKTtcbiAgICAgICAgdmFyIHNsaWNlQnVmZmVyID0gX2RlcmVxXygnYXJyYXlidWZmZXIuc2xpY2UnKTtcbiAgICAgICAgdmFyIGJhc2U2NGVuY29kZXIgPSBfZGVyZXFfKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbiAgICAgICAgdmFyIGFmdGVyID0gX2RlcmVxXygnYWZ0ZXInKTtcbiAgICAgICAgdmFyIHV0ZjggPSBfZGVyZXFfKCd1dGY4Jyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAgICAgICAgICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAgICAgICAgICpcbiAgICAgICAgICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGlzQW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAgICAgICAgICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGlzUGhhbnRvbUpTID0gL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAgICAgICAgICovXG5cbiAgICAgICAgZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhY2tldCB0eXBlcy5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgICAgICAgb3BlbjogMCAvLyBub24td3NcbiAgICAgICAgICAsIGNsb3NlOiAxIC8vIG5vbi13c1xuICAgICAgICAgICwgcGluZzogMixcbiAgICAgICAgICBwb25nOiAzLFxuICAgICAgICAgIG1lc3NhZ2U6IDQsXG4gICAgICAgICAgdXBncmFkZTogNSxcbiAgICAgICAgICBub29wOiA2XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgQmxvYiA9IF9kZXJlcV8oJ2Jsb2InKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyBhIHBhY2tldC5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgNWhlbGxvIHdvcmxkXG4gICAgICAgICAqICAgICAzXG4gICAgICAgICAqICAgICA0XG4gICAgICAgICAqXG4gICAgICAgICAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgICAgICAgICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgICAgICAgICAgdXRmOGVuY29kZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gICAgICAgICAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIGlmIChCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICAgICAgICAgIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgICAgICAgICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAgICAgICAgIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICAgICAgICAgKi9cblxuICAgICAgICBmdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICAgICAgICAgIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0QnVmZmVyW2kgKyAxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgICAgICAgICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICAgIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gICAgICAgICAqL1xuXG4gICAgICAgIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gICAgICAgICAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgICAgICAgICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgICAgICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGI2NGRhdGE7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICAgICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICAgICAgICAgIC8vIFN0cmluZyBkYXRhXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICAgICAgICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gICAgICAgICAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgICAgICAgICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICAgICAgICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICAgICAgICAgKi9cblxuICAgICAgICBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uIChtc2csIGJpbmFyeVR5cGUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICAgICAgICAgIGlmICghZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICAgICAgICAgIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIDxsZW5ndGg+OmRhdGFcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZTpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICAgICAgICAgKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICAgICAgICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICAgICAgICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgICAgICAgICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gICAgICAgICAqL1xuXG4gICAgICAgIGZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICAgICAgICAgIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgICAgICAgICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uIGVhY2hXaXRoSW5kZXgoaSwgZWwsIGNiKSB7XG4gICAgICAgICAgICBlYWNoKGVsLCBmdW5jdGlvbiAoZXJyb3IsIG1zZykge1xuICAgICAgICAgICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICAgICAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gICAgICAgICAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBleHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGFja2V0O1xuICAgICAgICAgIGlmIChkYXRhID09ICcnKSB7XG4gICAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gJycsXG4gICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgIG1zZztcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgICAgICAgICAgaWYgKCc6JyAhPSBjaHIpIHtcbiAgICAgICAgICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICgnJyA9PSBsZW5ndGggfHwgbGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgICAgICAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgICAgICAgICBpICs9IG47XG4gICAgICAgICAgICAgIGxlbmd0aCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGggIT0gJycpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gICAgICAgICAqIDI1NT48ZGF0YT5cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZTpcbiAgICAgICAgICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbiAoZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgICAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHApIHtcbiAgICAgICAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgICAgICAgICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICAgICAgICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgICB2YXIgYWIgPSBwO1xuICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZSBhcyBCbG9iXG4gICAgICAgICAqL1xuXG4gICAgICAgIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uIChwYWNrZXRzLCBjYWxsYmFjaykge1xuICAgICAgICAgIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgICAgICAgICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAoZW5jb2RlZCkge1xuICAgICAgICAgICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICAgICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGxlbiA9IGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGVuY29kZWQuYnl0ZUxlbmd0aCA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgICAgICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgICAgICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICAgICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAgICAgICAgICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICAgICAgICAgKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gICAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgICAqL1xuXG4gICAgICAgIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gICAgICAgICAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICAgICAgICAgIHZhciBudW1iZXJUb29Mb25nID0gZmFsc2U7XG4gICAgICAgICAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICAgICAgICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICAgICAgICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7OyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PSAyNTUpIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyVG9vTG9uZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtYmVyVG9vTG9uZykgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cbiAgICAgICAgICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgICAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgICAgICAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICAgICAgICAgIG1zZyA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgICAgICAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgICAgICAgICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlciwgaSkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbiAgICB9LCB7IFwiLi9rZXlzXCI6IDI4LCBcImFmdGVyXCI6IDYsIFwiYXJyYXlidWZmZXIuc2xpY2VcIjogNywgXCJiYXNlNjQtYXJyYXlidWZmZXJcIjogOSwgXCJibG9iXCI6IDEwLCBcImhhcy1iaW5hcnlcIjogMjksIFwidXRmOFwiOiA0NCB9XSwgMjg6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMob2JqKSB7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgICAgICAgYXJyLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9O1xuICAgIH0sIHt9XSwgMjk6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2R1bGUgZXhwb3J0cy5cbiAgICAgICAgICovXG5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBmdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gICAgICAgICAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICAgICAgICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYiB8fCBnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaikpKSB7XG4gICAgICAgICAgICAgIGlmIChvYmoudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KS5jYWxsKHRoaXMsIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xuICAgIH0sIHsgXCJpc2FycmF5XCI6IDMzIH1dLCAzMDogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZHVsZSBleHBvcnRzLlxuICAgICAgICAgKi9cblxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gICAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgICAqL1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgICAgICAgICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgICAgICAgICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IgfHwgZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopKSkge1xuICAgICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG4gICAgICAgICAgICAgIGlmIChvYmoudG9KU09OICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai50b0pTT04pIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhbGwodGhpcywgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG4gICAgfSwgeyBcImlzYXJyYXlcIjogMzMgfV0sIDMxOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgICAvKipcbiAgICAgICAqIE1vZHVsZSBleHBvcnRzLlxuICAgICAgICpcbiAgICAgICAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICAgICAgICpcbiAgICAgICAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICAgICAgICovXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gICAgICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHt9XSwgMzI6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICAgIHZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyLCBvYmopIHtcbiAgICAgICAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfTtcbiAgICB9LCB7fV0sIDMzOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9O1xuICAgIH0sIHt9XSwgMzQ6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAvKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG4gICAgICAgIDsoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAgICAgICAgIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gICAgICAgICAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICAgICAgICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICAgICAgICAgIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgICAgICAgIFwib2JqZWN0XCI6IHRydWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAgIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZXhwb3J0cyldICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAgICAgICAgIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gICAgICAgICAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgICAgICAgICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gICAgICAgICAgLy8gaW5zdGVhZC5cbiAgICAgICAgICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpXSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgICAgICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihtb2R1bGUpXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiAodHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGdsb2JhbCkpID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gICAgICAgICAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICAgICAgICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gICAgICAgICAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgICAgICAgICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgICAgICAgICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgICAgICAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgICAgICAgICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgICAgICAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICAgICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgICAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICAgICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgICAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICAgICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgICAgICAgICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBuYXRpdmVKU09OID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobmF0aXZlSlNPTikpID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgICAgICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICAgICAgICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgICAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgICAgICAgICBfaXNQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBfZm9yRWFjaCxcbiAgICAgICAgICAgICAgICB1bmRlZjtcblxuICAgICAgICAgICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgICAgICAgICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgICAgICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgICAgICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAgICAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgICAgICAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgICAgICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAgICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCA9IFwie1xcXCJhXFxcIjpbMSx0cnVlLGZhbHNlLG51bGwsXFxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcXFwiXX1cIjtcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksXG4gICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiYgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJiBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiYgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgICAgICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAgICAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgICAgICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAgICAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgICAgICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAgICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gZ2V0RGF5KHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAgICAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgICAgICAgICBpZiAoIShfaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIF9pc1Byb3BlcnR5ID0gZnVuY3Rpb24gaXNQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIF9pc1Byb3BlcnR5ID0gZnVuY3Rpb24gaXNQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgICAgICAgICBfaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIGlzUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICBfZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gMCxcbiAgICAgICAgICAgICAgICAgICAgUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAgICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAgICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgICAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgICAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgICAgICAgICAgaWYgKF9pc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICAgICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgIF9mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbX3R5cGVvZihvYmplY3QuaGFzT3duUHJvcGVydHkpXSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgX2lzUHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKSB7fVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICAgICAgICAgIF9mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFfaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBfaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgICAgICAgICAgX2ZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIF9pc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgX2lzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgICAgICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgICAgICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAgICAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgICAgICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgICAgICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAgICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgICAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAgICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgICAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICAgICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uIHRvUGFkZGVkU3RyaW5nKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgICAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiBxdW90ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpjYXNlIDk6Y2FzZSAxMDpjYXNlIDEyOmNhc2UgMTM6Y2FzZSAzNDpjYXNlIDkyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAgICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih2YWx1ZSkpID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFfaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKykge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKykge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcyB8fCBfaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHZhbHVlKSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/IHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIgOiBcIltdXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgICAgICAgICBfZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyB3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiIDogXCJ7fVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICAgICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGZpbHRlcildICYmIGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSkge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpIHt9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAgICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgICAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgICAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICAgICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGJlZ2luLFxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGlzU2lnbmVkLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OmNhc2UgMTA6Y2FzZSAxMzpjYXNlIDMyOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMzpjYXNlIDEyNTpjYXNlIDkxOmNhc2UgOTM6Y2FzZSA1ODpjYXNlIDQ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjpjYXNlIDM0OmNhc2UgNDc6Y2FzZSA5ODpjYXNlIDExNjpjYXNlIDExMDpjYXNlIDEwMjpjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICAgICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiBnZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgICAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICAgICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSxcbiAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHZhbHVlKSkgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX2ZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAgICAgICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICAgICAgICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCByb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAgICAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgICAgICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICAgICAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgICAgICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgICAgICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICAgICAgICAgIGlmIChpc0xvYWRlcikge1xuICAgICAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbiAgICB9LCB7fV0sIDM1OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgLyoqXG4gICAgICAgKiBIZWxwZXJzLlxuICAgICAgICovXG5cbiAgICAgIHZhciBzID0gMTAwMDtcbiAgICAgIHZhciBtID0gcyAqIDYwO1xuICAgICAgdmFyIGggPSBtICogNjA7XG4gICAgICB2YXIgZCA9IGggKiAyNDtcbiAgICAgIHZhciB5ID0gZCAqIDM2NS4yNTtcblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICAgICAgICpcbiAgICAgICAqIE9wdGlvbnM6XG4gICAgICAgKlxuICAgICAgICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGxvbmcodmFsKSA6IHNob3J0KHZhbCk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICAgICAgc3RyID0gJycgKyBzdHI7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcbiAgICAgICAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIW1hdGNoKSByZXR1cm47XG4gICAgICAgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICBjYXNlICd5cnMnOlxuICAgICAgICAgIGNhc2UgJ3lyJzpcbiAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIHJldHVybiBuICogeTtcbiAgICAgICAgICBjYXNlICdkYXlzJzpcbiAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgcmV0dXJuIG4gKiBkO1xuICAgICAgICAgIGNhc2UgJ2hvdXJzJzpcbiAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICBjYXNlICdocnMnOlxuICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHJldHVybiBuICogaDtcbiAgICAgICAgICBjYXNlICdtaW51dGVzJzpcbiAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgIGNhc2UgJ21pbnMnOlxuICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIG07XG4gICAgICAgICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICBjYXNlICdzZWNzJzpcbiAgICAgICAgICBjYXNlICdzZWMnOlxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmV0dXJuIG4gKiBzO1xuICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgIGNhc2UgJ21zZWNzJzpcbiAgICAgICAgICBjYXNlICdtc2VjJzpcbiAgICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gbXNcbiAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gICAgICAgIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICAgICAgICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgICAgICAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gICAgICAgIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICAgICAgICByZXR1cm4gbXMgKyAnbXMnO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gbG9uZyhtcykge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8IG1zICsgJyBtcyc7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gICAgICAgIGlmIChtcyA8IG4pIHJldHVybjtcbiAgICAgICAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG4gICAgICB9XG4gICAgfSwge31dLCAzNjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBKU09OIHBhcnNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG4gICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcbiAgICAgICAgdmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG4gICAgICAgIHZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG4gICAgICAgIHZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG4gICAgICAgIHZhciBydHJpbUxlZnQgPSAvXlxccysvO1xuICAgICAgICB2YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XG5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuICAgICAgICAgIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSB8fCAhZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcblxuICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICAgICAgICAgIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbiAgICB9LCB7fV0sIDM3OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgLyoqXG4gICAgICAgKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG4gICAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9XG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XG4gICAgICAgICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHFzXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChxcykge1xuICAgICAgICB2YXIgcXJ5ID0ge307XG4gICAgICAgIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgICAgICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxcnk7XG4gICAgICB9O1xuICAgIH0sIHt9XSwgMzg6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAvKipcbiAgICAgICAqIFBhcnNlcyBhbiBVUklcbiAgICAgICAqXG4gICAgICAgKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICB2YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxuICAgICAgdmFyIHBhcnRzID0gWydzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ107XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XG4gICAgICAgIHZhciBzcmMgPSBzdHIsXG4gICAgICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgICAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xuXG4gICAgICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICAgICAgICB1cmkgPSB7fSxcbiAgICAgICAgICAgIGkgPSAxNDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgfTtcbiAgICB9LCB7fV0sIDM5OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgLypnbG9iYWwgQmxvYixGaWxlKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTtcbiAgICAgICAgdmFyIGlzQnVmID0gX2RlcmVxXygnLi9pcy1idWZmZXInKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAgICAgICAgICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICAgICAgICAgKiBoZXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cblxuICAgICAgICBleHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgICAgIHZhciBidWZmZXJzID0gW107XG4gICAgICAgICAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gICAgICAgICAgICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSAodHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkYXRhKSkgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYWNrID0gcGFja2V0O1xuICAgICAgICAgIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtcbiAgICAgICAgICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICAgICAgICAgIHJldHVybiB7IHBhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVycyB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAgICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgICovXG5cbiAgICAgICAgZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgICAgICAgICB2YXIgY3VyUGxhY2VIb2xkZXIgPSAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgIHZhciBidWYgPSBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSAodHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkYXRhKSkpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcbiAgICAgICAgICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgICAgICAgICByZXR1cm4gcGFja2V0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAgICAgICAgICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAgICAgICAgICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICAgICAgICAgIGlmIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iIHx8IGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgICAgICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgICAgICAgICBpZiAoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAvLyBoYW5kbGUgYXJyYXlcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaikpICYmICFpc0J1ZihvYmopKSB7XG4gICAgICAgICAgICAgIC8vIGFuZCBvYmplY3RcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gICAgICAgICAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gICAgICAgICAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgICAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbiAgICB9LCB7IFwiLi9pcy1idWZmZXJcIjogNDEsIFwiaXNhcnJheVwiOiAzMyB9XSwgNDA6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICAgICAqL1xuXG4gICAgICB2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG4gICAgICB2YXIganNvbiA9IF9kZXJlcV8oJ2pzb24zJyk7XG4gICAgICB2YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTtcbiAgICAgIHZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcbiAgICAgIHZhciBiaW5hcnkgPSBfZGVyZXFfKCcuL2JpbmFyeScpO1xuICAgICAgdmFyIGlzQnVmID0gX2RlcmVxXygnLi9pcy1idWZmZXInKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm90b2NvbCB2ZXJzaW9uLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFja2V0IHR5cGVzLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZXhwb3J0cy50eXBlcyA9IFsnQ09OTkVDVCcsICdESVNDT05ORUNUJywgJ0VWRU5UJywgJ0FDSycsICdFUlJPUicsICdCSU5BUllfRVZFTlQnLCAnQklOQVJZX0FDSyddO1xuXG4gICAgICAvKipcbiAgICAgICAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIGV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuICAgICAgLyoqXG4gICAgICAgKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICAgICAgICpcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgZXhwb3J0cy5FVkVOVCA9IDI7XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFja2V0IHR5cGUgYGFja2AuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLkFDSyA9IDM7XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIGV4cG9ydHMuRVJST1IgPSA0O1xuXG4gICAgICAvKipcbiAgICAgICAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBleHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICAgICAgICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAgICAgICAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgKi9cblxuICAgICAgRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgICAgICAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgICAgICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgICAgICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAgICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICB2YXIgbnNwID0gZmFsc2U7XG5cbiAgICAgICAgLy8gZmlyc3QgaXMgdHlwZVxuICAgICAgICBzdHIgKz0gb2JqLnR5cGU7XG5cbiAgICAgICAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gICAgICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICAgICAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzO1xuICAgICAgICAgIHN0ciArPSAnLSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gICAgICAgIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICAgICAgICBpZiAob2JqLm5zcCAmJiAnLycgIT0gb2JqLm5zcCkge1xuICAgICAgICAgIG5zcCA9IHRydWU7XG4gICAgICAgICAgc3RyICs9IG9iai5uc3A7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgICAgICAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgICAgICAgaWYgKG5zcCkge1xuICAgICAgICAgICAgc3RyICs9ICcsJztcbiAgICAgICAgICAgIG5zcCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gb2JqLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8ganNvbiBkYXRhXG4gICAgICAgIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgICAgICAgaWYgKG5zcCkgc3RyICs9ICcsJztcbiAgICAgICAgICBzdHIgKz0ganNvbi5zdHJpbmdpZnkob2JqLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoJ2VuY29kZWQgJWogYXMgJXMnLCBvYmosIHN0cik7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gICAgICAgKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gICAgICAgKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuICAgICAgICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuICAgICAgICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuICAgICAgICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICAgICAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cbiAgICAgICAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgICAgICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICAgICAgICB9XG5cbiAgICAgICAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBEZWNvZGVyKCkge1xuICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICAgICAgICovXG5cbiAgICAgIEVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZXMgYW4gZWNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIERlY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIHBhY2tldDtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICAgICAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICAgICAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzQnVmKG9iaikgfHwgb2JqLmJhc2U2NCkge1xuICAgICAgICAgIC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgICAgICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgICAgICAgIGlmIChwYWNrZXQpIHtcbiAgICAgICAgICAgICAgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIHAgPSB7fTtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIC8vIGxvb2sgdXAgdHlwZVxuICAgICAgICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG4gICAgICAgIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cbiAgICAgICAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICAgICAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcbiAgICAgICAgICB2YXIgYnVmID0gJyc7XG4gICAgICAgICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcbiAgICAgICAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPSAnLScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICAgICAgICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgICAgICAgcC5uc3AgPSAnJztcbiAgICAgICAgICB3aGlsZSAoKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuICAgICAgICAgICAgcC5uc3AgKz0gYztcbiAgICAgICAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwLm5zcCA9ICcvJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvb2sgdXAgaWRcbiAgICAgICAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgICAgICAgcC5pZCA9ICcnO1xuICAgICAgICAgIHdoaWxlICgrK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAgICAgICAqXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIERlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAgICAgICAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gICAgICAgKiBkZWNvZGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgICAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gICAgICAgIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gICAgICAgKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAgICAgICAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gICAgICAgKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIEJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24gKGJpbkRhdGEpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgICAgICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICAgICAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICAgICAgICByZXR1cm4gcGFja2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gICAgICAgKlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGVycm9yKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgICAgICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgeyBcIi4vYmluYXJ5XCI6IDM5LCBcIi4vaXMtYnVmZmVyXCI6IDQxLCBcImNvbXBvbmVudC1lbWl0dGVyXCI6IDQyLCBcImRlYnVnXCI6IDE0LCBcImlzYXJyYXlcIjogMzMsIFwianNvbjNcIjogMzQgfV0sIDQxOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcblxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICAgICAgZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbiAgICB9LCB7fV0sIDQyOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgYXJndW1lbnRzWzRdWzI2XVswXS5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgIH0sIHsgXCJkdXBcIjogMjYgfV0sIDQzOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5O1xuXG4gICAgICBmdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cbiAgICB9LCB7fV0sIDQ0OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMC4wIGJ5IEBtYXRoaWFzICovXG4gICAgICAgIDsoZnVuY3Rpb24gKHJvb3QpIHtcblxuICAgICAgICAgIC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2BcbiAgICAgICAgICB2YXIgZnJlZUV4cG9ydHMgPSAodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihleHBvcnRzKSkgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuICAgICAgICAgIC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG4gICAgICAgICAgdmFyIGZyZWVNb2R1bGUgPSAodHlwZW9mIG1vZHVsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG1vZHVsZSkpID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cbiAgICAgICAgICAvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuICAgICAgICAgIC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG4gICAgICAgICAgdmFyIGZyZWVHbG9iYWwgPSAodHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGdsb2JhbCkpID09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgICAgICAgICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcbiAgICAgICAgICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgICAvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuICAgICAgICAgIGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHZhciBleHRyYTtcbiAgICAgICAgICAgIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgICAgICAgICBpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG4gICAgICAgICAgZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDB4RkZGRikge1xuICAgICAgICAgICAgICAgIHZhbHVlIC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+IHNoaWZ0ICYgMHgzRiB8IDB4ODApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgIGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkge1xuICAgICAgICAgICAgICAvLyAxLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN5bWJvbCA9ICcnO1xuICAgICAgICAgICAgaWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIDItYnl0ZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICBzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+IDYgJiAweDFGIHwgMHhDMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIDMtYnl0ZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgIHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQgPj4gMTIgJiAweDBGIHwgMHhFMCk7XG4gICAgICAgICAgICAgIHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIDQtYnl0ZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICBzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+IDE4ICYgMHgwNyB8IDB4RjApO1xuICAgICAgICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcbiAgICAgICAgICAgICAgc3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ICYgMHgzRiB8IDB4ODApO1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgICAgICAgICB2YXIgYnl0ZVN0cmluZyA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG4gICAgICAgICAgICAgIGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZVN0cmluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuICAgICAgICAgICAgaWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcbiAgICAgICAgICAgIGJ5dGVJbmRleCsrO1xuXG4gICAgICAgICAgICBpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZTE7XG4gICAgICAgICAgICB2YXIgYnl0ZTI7XG4gICAgICAgICAgICB2YXIgYnl0ZTM7XG4gICAgICAgICAgICB2YXIgYnl0ZTQ7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50O1xuXG4gICAgICAgICAgICBpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWFkIGZpcnN0IGJ5dGVcbiAgICAgICAgICAgIGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuICAgICAgICAgICAgYnl0ZUluZGV4Kys7XG5cbiAgICAgICAgICAgIC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuICAgICAgICAgICAgaWYgKChieXRlMSAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJ5dGUxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAyLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgICAgIGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG4gICAgICAgICAgICAgIHZhciBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IChieXRlMSAmIDB4MUYpIDw8IDYgfCBieXRlMjtcbiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcbiAgICAgICAgICAgIGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG4gICAgICAgICAgICAgIGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgICAgICAgYnl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAoYnl0ZTEgJiAweDBGKSA8PCAxMiB8IGJ5dGUyIDw8IDYgfCBieXRlMztcbiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcbiAgICAgICAgICAgICAgICBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDQtYnl0ZSBzZXF1ZW5jZVxuICAgICAgICAgICAgaWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcbiAgICAgICAgICAgICAgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICAgICAgICBieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgICAgICAgIGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gKGJ5dGUxICYgMHgwRikgPDwgMHgxMiB8IGJ5dGUyIDw8IDB4MEMgfCBieXRlMyA8PCAweDA2IHwgYnl0ZTQ7XG4gICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBieXRlQXJyYXk7XG4gICAgICAgICAgdmFyIGJ5dGVDb3VudDtcbiAgICAgICAgICB2YXIgYnl0ZUluZGV4O1xuICAgICAgICAgIGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuICAgICAgICAgICAgYnl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcbiAgICAgICAgICAgIGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICBieXRlSW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHZhciB0bXA7XG4gICAgICAgICAgICB3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50cy5wdXNoKHRtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgIHZhciB1dGY4ID0ge1xuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMi4wLjAnLFxuICAgICAgICAgICAgJ2VuY29kZSc6IHV0ZjhlbmNvZGUsXG4gICAgICAgICAgICAnZGVjb2RlJzogdXRmOGRlY29kZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcbiAgICAgICAgICAvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBfdHlwZW9mKGRlZmluZS5hbWQpID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1dGY4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgICAgICAgICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG4gICAgICAgICAgICAgIGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHV0ZjgpIHtcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcbiAgICAgICAgICAgIHJvb3QudXRmOCA9IHV0Zjg7XG4gICAgICAgICAgfVxuICAgICAgICB9KSh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG4gICAgfSwge31dLCA0NTogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKSxcbiAgICAgICAgICBsZW5ndGggPSA2NCxcbiAgICAgICAgICBtYXAgPSB7fSxcbiAgICAgICAgICBzZWVkID0gMCxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBwcmV2O1xuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gICAgICAgIHZhciBlbmNvZGVkID0gJyc7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG4gICAgICAgIH0gd2hpbGUgKG51bSA+IDApO1xuXG4gICAgICAgIHJldHVybiBlbmNvZGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gICAgICAgIHZhciBkZWNvZGVkID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24geWVhc3QoKSB7XG4gICAgICAgIHZhciBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuXG4gICAgICAgIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcbiAgICAgICAgcmV0dXJuIG5vdyArICcuJyArIGVuY29kZShzZWVkKyspO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbiAgICAgIC8vXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuICAgICAgfSAvL1xuICAgICAgLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuICAgICAgLy9cbiAgICAgIHllYXN0LmVuY29kZSA9IGVuY29kZTtcbiAgICAgIHllYXN0LmRlY29kZSA9IGRlY29kZTtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG4gICAgfSwge31dIH0sIHt9LCBbMV0pKDEpO1xufSk7XG5cbmNjLl9SRi5wb3AoKTsiXX0=","deps":{}},"/Users/splspeco/Documents/ggame/library/imports/fb/fb6a625a-f5d3-4e3f-96e7-973a2f7a1304.js":{"source":"\"use strict\";\ncc._RF.push(module, 'fb6a6Ja9dNOP5bnlzovehME', 'array1');\n// script/library/array1.js\n\n\"use strict\";\n\ncc.Class({\n\n    properties: {\n        // foo: {\n        //    default: null,      // The default value will be used only when the component attaching\n        //                           to a node for the first time\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n        list: [],\n        size: 0,\n        npos: -1\n    },\n    // use this for initialization\n    onLoad: function onLoad() {\n        console.log(\"worked\");\n    },\n\n    asfdfsdf: function asfdfsdf() {\n        console.log(\"wocao\");\n        // console.log(typeof this.list);\n        console.log(\"wocao\");\n    },\n\n    status: function status() {\n        console.log(\"self.size1\");\n        console.log(this.size);\n        console.log(\"self.size2\");\n    },\n    //\n    pushBack: function pushBack(data) {\n        this.list[this.size] = data;\n        this.size = this.size + 1;\n    },\n\n    at: function at(idx) {\n        return this.list[idx];\n    },\n\n    find: function find(value) {\n        var index = this.npos;\n        if (typeof value == \"function\") {\n            for (i = 0; i < this.size; i++) {\n                if (value(i)) return i;\n            }\n        } else {\n            for (i = 0; i < this.size; i++) {\n                if (this.list[i] == value) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        return index;\n    },\n\n    remove: function remove(pos, len) {\n        if (pos < 0) pos = 0;\n        if (len == null || len <= 0) {\n            len = 1;\n        }\n        if (pos < this.size) {\n            if (pos + len > this.size) len = this.size - pos;\n            for (i = 0; i < len; i++) {\n                delete this.list[pos + i];\n            }for (i = pos + len; i < this.size; i++) {\n                this.list[i - len] = this.list[i];\n            }this.size = this.size - len;\n        }\n    },\n\n    clear: function clear() {\n        for (i = 0; i < this.size; i++) {\n            delete this.list[i];\n        }this.size = 0;\n    },\n\n    getSize: function getSize() {\n        return this.size;\n    },\n\n    back: function back() {\n        if (this.size > 0) {\n            return this.list[this.size - 1];\n        } else {\n            return null;\n        }\n    },\n\n    empty: function empty() {\n        return this.size == 0;\n    },\n\n    outPut: function outPut() {\n        for (i = 0; i < this.size; i++) {\n            console.log(\"element\" + i + \" = \" + this.list[i]);\n        }console.log(\"element size = \" + this.size);\n    },\n\n    excuteWithFunc: function excuteWithFunc(func) {\n        for (var i = 0; i < this.size; i++) {\n            func(this.list[i], i);\n        }\n    },\n\n    popBack: function popBack() {\n        if (this.size > 0) {\n            delete this.list[this.size - 1];\n            this.size = this.size - 1;\n        }\n    }\n\n});\n\ncc._RF.pop();","deps":{}}},"packageCache":{"/Users/splspeco/Documents/ggame/assets/script/package.json":false,"/Users/splspeco/Documents/ggame/assets/package.json":false,"/Users/splspeco/Documents/ggame/package.json":false,"/Users/splspeco/Documents/package.json":false,"/Users/splspeco/package.json":false,"/Users/package.json":false,"/package.json":false,"/Users/splspeco/Documents/ggame/assets/script/appStart.js":false,"/Users/splspeco/Documents/ggame/assets/script/library/package.json":false,"/Users/splspeco/Documents/ggame/assets/script/library/array1.js":false,"/Users/splspeco/Documents/ggame/assets/script/tool/package.json":false,"/Users/splspeco/Documents/ggame/assets/script/tool/viewManager.js":false,"/Users/splspeco/Documents/ggame/assets/script/tool/viewRegister.js":false,"/Users/splspeco/Documents/ggame/library/imports/03/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/fb/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/c2/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/8f/package.json":false,"/Users/splspeco/Documents/ggame/library/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/fb/fb6a625a-f5d3-4e3f-96e7-973a2f7a1304.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/fb"},"/Users/splspeco/Documents/ggame/library/imports/c2/c2b58435-fd5e-48a7-8736-577bae06247a.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/c2"},"/Users/splspeco/Documents/ggame/library/imports/8f/8f625656-d45f-4ed9-934b-5999ae140e41.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/8f"},"/Users/splspeco/Documents/ggame/library/imports/03/03b75b8c-1d50-4a25-a557-9d9ee429cb9e.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/03"},"/Users/splspeco/Documents/ggame/assets/script/tool/NewScript.js":false,"/Users/splspeco/Documents/ggame/library/imports/d1/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/d1/d1f6d160-3543-49da-a12f-e0853acf5abe.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/d1"},"/Users/splspeco/Documents/ggame/assets/script/tool/eventManager.js":false,"/Users/splspeco/Documents/ggame/library/imports/e3/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/e3/e33a4d6e-3979-4e7c-9b13-a4f530f47026.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/e3"},"/Users/splspeco/Documents/ggame/assets/script/tool/test.js":false,"/Users/splspeco/Documents/ggame/assets/resources/modules/package.json":false,"/Users/splspeco/Documents/ggame/assets/resources/package.json":false,"/Users/splspeco/Documents/ggame/assets/resources/modules/NewScript.js":false,"/Users/splspeco/Documents/ggame/library/imports/66/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/66/66ecccd9-e6e6-4138-a2c4-aea5e79067e7.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/66"},"/Users/splspeco/Documents/ggame/assets/script/control/package.json":false,"/Users/splspeco/Documents/ggame/assets/script/control/ListView.js":false,"/Users/splspeco/Documents/ggame/library/imports/1e/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/1e/1ec2958d-7e4a-48fb-bf0a-ddd9ad53a7f2.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/1e"},"/Users/splspeco/Documents/ggame/assets/script/process/package.json":false,"/Users/splspeco/Documents/ggame/assets/script/process/Timehandler.js":false,"/Users/splspeco/Documents/ggame/library/imports/97/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/97/977cc0e1-2e1d-414e-8141-f64843a5d362.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/97"},"/Users/splspeco/Documents/ggame/assets/script/process/timeHandler.js":false,"/Users/splspeco/Documents/ggame/assets/script/control/listView.js":false,"/Users/splspeco/Documents/ggame/assets/script/config/package.json":false,"/Users/splspeco/Documents/ggame/assets/script/config/langZh.js":false,"/Users/splspeco/Documents/ggame/library/imports/26/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/26/269e126c-e5ab-48f7-9161-f9928ea7591b.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/26"},"/Users/splspeco/Documents/ggame/assets/resources/control/package.json":false,"/Users/splspeco/Documents/ggame/assets/resources/control/listView.js":false,"/Users/splspeco/Documents/ggame/assets/resources/control/ListView.js":false,"/Users/splspeco/Documents/ggame/assets/script/config/NewScript.js":false,"/Users/splspeco/Documents/ggame/library/imports/1d/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/1d/1de312e6-a5a6-490e-b84d-9baf27f94748.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/1d"},"/Users/splspeco/Documents/ggame/assets/script/config/config.js":false,"/Users/splspeco/Documents/ggame/assets/script/NewScript.ts":false,"/Users/splspeco/Documents/ggame/library/imports/2e/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/2e/2e1f3d7e-ddfb-4a34-b096-7593b08b2c12.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/2e"},"/Users/splspeco/Documents/ggame/assets/script/tsTest.ts":false,"/Users/splspeco/Documents/ggame/assets/script/testTs.ts":false,"/Users/splspeco/Documents/ggame/assets/resources/control/NewScript.js":false,"/Users/splspeco/Documents/ggame/library/imports/17/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/17/1746aaa6-34f4-400c-b772-91c17f67730b.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/17"},"/Users/splspeco/Documents/ggame/assets/resources/control/Renderer.js":false,"/Users/splspeco/Documents/ggame/assets/script/module/package.json":false,"/Users/splspeco/Documents/ggame/assets/script/module/NewScript.js":false,"/Users/splspeco/Documents/ggame/library/imports/e3/e3999068-9648-49a5-84b6-27fc6eb337db.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/e3"},"/Users/splspeco/Documents/ggame/assets/script/module/kmView.js":false,"/Users/splspeco/Documents/ggame/assets/script/variable/package.json":false,"/Users/splspeco/Documents/ggame/assets/script/variable/NewScript.js":false,"/Users/splspeco/Documents/ggame/library/imports/cc/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/cc/ccacc66a-5bd8-4f79-90c7-b298d3bbe0cb.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/cc"},"/Users/splspeco/Documents/ggame/assets/script/variable/gameVariable.js":false,"/Users/splspeco/Documents/ggame/library/imports/a5/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/a5/a508d847-3b2e-4916-9df9-7d0fd56f61b0.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/a5"},"/Users/splspeco/Documents/ggame/assets/script/tool/urlManager.js":false,"/Users/splspeco/Documents/ggame/assets/script/tool/socket.io.js":false,"/Users/splspeco/Documents/ggame/library/imports/fd/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/fd/fd72895b-77f7-44f7-b9fe-8dde69e84d0c.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/fd"},"/Users/splspeco/Documents/ggame/library/imports/25/package.json":false,"/Users/splspeco/Documents/ggame/library/imports/25/25f6293b-798b-438e-aea3-9aa9f8bbd43f.js":{"__dirname":"/Users/splspeco/Documents/ggame/library/imports/25"}}}}